---- CSCompiler.Add
new Expression<Func<double>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<double>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.Add,
        Type = typeof(double),
        Left = new MemberExpression {
            Type = typeof(double),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("x")
        },
        Right = new MemberExpression {
            Type = typeof(double),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("y")
        }
    },
    ReturnType = typeof(double)
}
---- CSCompiler.AndAlso
new Expression<Func<bool>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<bool>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.AndAlso,
        Type = typeof(bool),
        Left = new MemberExpression {
            Type = typeof(bool),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("b1")
        },
        Right = new MemberExpression {
            Type = typeof(bool),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("b2")
        }
    },
    ReturnType = typeof(bool)
}
---- CSCompiler.AndBitwise
new Expression<Func<int>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<int>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.And,
        Type = typeof(int),
        Left = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("i")
        },
        Right = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("j")
        }
    },
    ReturnType = typeof(int)
}
---- CSCompiler.AndLogical
new Expression<Func<bool>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<bool>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.And,
        Type = typeof(bool),
        Left = new MemberExpression {
            Type = typeof(bool),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("b1")
        },
        Right = new MemberExpression {
            Type = typeof(bool),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("b2")
        }
    },
    ReturnType = typeof(bool)
}
---- CSCompiler.AnonymousType
new Expression<Func<{ string Bar, string Baz }>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<{ string Bar, string Baz }>),
    Body = new NewExpression {
        Type = typeof(<anonymous({ string Bar, string Baz })>),
        Arguments = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(string),
                Value = "abcd"
            },
            new ConstantExpression {
                Type = typeof(string),
                Value = "efgh"
            }
        },
        Constructor = typeof(<anonymous({ string Bar, string Baz })>).GetConstructor(new[] { typeof(string), typeof(string) }),
        Members = #TrueReadOnlyCollection<MemberInfo>
    },
    ReturnType = typeof(<anonymous({ string Bar, string Baz })>)
}
---- CSCompiler.AnonymousTypeFromVariables
new Expression<Func<{ string Bar, string Baz }>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<{ string Bar, string Baz }>),
    Body = new NewExpression {
        Type = typeof(<anonymous({ string Bar, string Baz })>),
        Arguments = new ReadOnlyCollection<Expression> {
            new MemberExpression {
                Type = typeof(string),
                Expression = new ConstantExpression {
                    Type = typeof(<closure>),
                    Value = #<closure>
                },
                Member = typeof(<closure>).GetField("Bar")
            },
            new MemberExpression {
                Type = typeof(string),
                Expression = new ConstantExpression {
                    Type = typeof(<closure>),
                    Value = #<closure>
                },
                Member = typeof(<closure>).GetField("Baz")
            }
        },
        Constructor = typeof(<anonymous({ string Bar, string Baz })>).GetConstructor(new[] { typeof(string), typeof(string) }),
        Members = #TrueReadOnlyCollection<MemberInfo>
    },
    ReturnType = typeof(<anonymous({ string Bar, string Baz })>)
}
---- CSCompiler.ArrayIndex
new Expression<Func<string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.ArrayIndex,
        Type = typeof(string),
        Left = new MemberExpression {
            Type = typeof(string[]),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("arr")
        },
        Right = new ConstantExpression {
            Type = typeof(int),
            Value = 0
        }
    },
    ReturnType = typeof(string)
}
---- CSCompiler.ArrayLength
new Expression<Func<int>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<int>),
    Body = new UnaryExpression {
        NodeType = ExpressionType.ArrayLength,
        Type = typeof(int),
        Operand = new MemberExpression {
            Type = typeof(string[]),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("arr")
        }
    },
    ReturnType = typeof(int)
}
---- CSCompiler.ArrayMultipleIndex
new Expression<Func<string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string>),
    Body = new MethodCallExpression {
        Type = typeof(string),
        Object = new MemberExpression {
            Type = typeof(string[,]),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("arr")
        },
        Arguments = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(int),
                Value = 5
            },
            new ConstantExpression {
                Type = typeof(int),
                Value = 6
            }
        },
        Method = typeof(string[,]).GetMethod("Get")
    },
    ReturnType = typeof(string)
}
---- CSCompiler.ArrayOfMultidimensionalArray
new Expression<Func<string[][,]>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string[][,]>),
    Body = new NewArrayExpression {
        NodeType = ExpressionType.NewArrayBounds,
        Type = typeof(string[][,]),
        Expressions = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(int),
                Value = 5
            }
        }
    },
    ReturnType = typeof(string[][,])
}
---- CSCompiler.ArraySingleIndex
new Expression<Func<string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.ArrayIndex,
        Type = typeof(string),
        Left = new MemberExpression {
            Type = typeof(string[]),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("arr")
        },
        Right = new ConstantExpression {
            Type = typeof(int),
            Value = 5
        }
    },
    ReturnType = typeof(string)
}
---- CSCompiler.BitwiseNot
new Expression<Func<int>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<int>),
    Body = new UnaryExpression {
        NodeType = ExpressionType.Not,
        Type = typeof(int),
        Operand = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("i")
        }
    },
    ReturnType = typeof(int)
}
---- CSCompiler.ClosedVariable
new Expression<Func<string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string>),
    Body = new MemberExpression {
        Type = typeof(string),
        Expression = new ConstantExpression {
            Type = typeof(<closure>),
            Value = #<closure>
        },
        Member = typeof(<closure>).GetField("s")
    },
    ReturnType = typeof(string)
}
---- CSCompiler.Coalesce
new Expression<Func<string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.Coalesce,
        Type = typeof(string),
        Left = new MemberExpression {
            Type = typeof(string),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("s1")
        },
        Right = new MemberExpression {
            Type = typeof(string),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("s2")
        }
    },
    ReturnType = typeof(string)
}
---- CSCompiler.CollectionTypeWithInitializer
new Expression<Func<List<string>>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<List<string>>),
    Body = new ListInitExpression {
        Type = typeof(List<string>),
        NewExpression = new NewExpression {
            Type = typeof(List<string>),
            Constructor = typeof(List<string>).GetConstructor(new Type[] { })
        },
        Initializers = new ReadOnlyCollection<ElementInit> {
            new ElementInit {
                AddMethod = typeof(List<string>).GetMethod("Add"),
                Arguments = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(string),
                        Value = "abcd"
                    }
                }
            },
            new ElementInit {
                AddMethod = typeof(List<string>).GetMethod("Add"),
                Arguments = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(string),
                        Value = "efgh"
                    }
                }
            }
        }
    },
    ReturnType = typeof(List<string>)
}
---- CSCompiler.CollectionTypeWithMultipleElementsInitializers
new Expression<Func<Wrapper>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<Wrapper>),
    Body = new ListInitExpression {
        Type = typeof(Wrapper),
        NewExpression = new NewExpression {
            Type = typeof(Wrapper),
            Constructor = typeof(Wrapper).GetConstructor(new Type[] { })
        },
        Initializers = new ReadOnlyCollection<ElementInit> {
            new ElementInit {
                AddMethod = typeof(Wrapper).GetMethod("Add", BindingFlags.Instance | BindingFlags.NonPublic),
                Arguments = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(string),
                        Value = "ab"
                    },
                    new ConstantExpression {
                        Type = typeof(string),
                        Value = "cd"
                    }
                }
            },
            new ElementInit {
                AddMethod = typeof(Wrapper).GetMethod("Add", BindingFlags.Instance | BindingFlags.NonPublic),
                Arguments = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(string),
                        Value = "ef"
                    },
                    new ConstantExpression {
                        Type = typeof(string),
                        Value = "gh"
                    }
                }
            }
        }
    },
    ReturnType = typeof(Wrapper)
}
---- CSCompiler.CollectionTypeWithSingleOrMultipleElementsInitializers
new Expression<Func<Wrapper>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<Wrapper>),
    Body = new ListInitExpression {
        Type = typeof(Wrapper),
        NewExpression = new NewExpression {
            Type = typeof(Wrapper),
            Constructor = typeof(Wrapper).GetConstructor(new Type[] { })
        },
        Initializers = new ReadOnlyCollection<ElementInit> {
            new ElementInit {
                AddMethod = typeof(Wrapper).GetMethod("Add", BindingFlags.Instance | BindingFlags.NonPublic),
                Arguments = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(string),
                        Value = "ab"
                    },
                    new ConstantExpression {
                        Type = typeof(string),
                        Value = "cd"
                    }
                }
            },
            new ElementInit {
                AddMethod = typeof(List<string>).GetMethod("Add"),
                Arguments = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(string),
                        Value = "ef"
                    }
                }
            }
        }
    },
    ReturnType = typeof(Wrapper)
}
---- CSCompiler.Conditional
var i = new ParameterExpression {
    Type = typeof(int),
    IsByRef = false,
    Name = "i"
};

new Expression<Func<int, int>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<int, int>),
    Parameters = new ReadOnlyCollection<ParameterExpression> {
        i
    },
    Body = new ConditionalExpression {
        Type = typeof(int),
        Test = new BinaryExpression {
            NodeType = ExpressionType.GreaterThan,
            Type = typeof(bool),
            Left = i,
            Right = new ConstantExpression {
                Type = typeof(int),
                Value = 10
            }
        },
        IfTrue = i,
        IfFalse = new BinaryExpression {
            NodeType = ExpressionType.Add,
            Type = typeof(int),
            Left = i,
            Right = new ConstantExpression {
                Type = typeof(int),
                Value = 10
            }
        }
    },
    ReturnType = typeof(int)
}
---- CSCompiler.Convert
new Expression<Func<object>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<object>),
    Body = new UnaryExpression {
        NodeType = ExpressionType.Convert,
        Type = typeof(object),
        Operand = new MemberExpression {
            Type = typeof(List<string>),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("lst")
        }
    },
    ReturnType = typeof(object)
}
---- CSCompiler.DefaultRefType
new Expression<Func<string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string>),
    Body = new ConstantExpression {
        Type = typeof(string)
    },
    ReturnType = typeof(string)
}
---- CSCompiler.DefaultValueType
new Expression<Func<int>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<int>),
    Body = new ConstantExpression {
        Type = typeof(int),
        Value = 0
    },
    ReturnType = typeof(int)
}
---- CSCompiler.Divide
new Expression<Func<double>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<double>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.Divide,
        Type = typeof(double),
        Left = new MemberExpression {
            Type = typeof(double),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("x")
        },
        Right = new MemberExpression {
            Type = typeof(double),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("y")
        }
    },
    ReturnType = typeof(double)
}
---- CSCompiler.Equal
new Expression<Func<bool>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<bool>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.Equal,
        Type = typeof(bool),
        Left = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("i")
        },
        Right = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("j")
        }
    },
    ReturnType = typeof(bool)
}
---- CSCompiler.ExclusiveOrBitwise
new Expression<Func<int>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<int>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.ExclusiveOr,
        Type = typeof(int),
        Left = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("i")
        },
        Right = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("j")
        }
    },
    ReturnType = typeof(int)
}
---- CSCompiler.ExclusiveOrLogical
new Expression<Func<bool>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<bool>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.ExclusiveOr,
        Type = typeof(bool),
        Left = new MemberExpression {
            Type = typeof(bool),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("b1")
        },
        Right = new MemberExpression {
            Type = typeof(bool),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("b2")
        }
    },
    ReturnType = typeof(bool)
}
---- CSCompiler.ExtensionMethod0Arguments
new Expression<Func<int>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<int>),
    Body = new MethodCallExpression {
        Type = typeof(int),
        Arguments = new ReadOnlyCollection<Expression> {
            new MemberExpression {
                Type = typeof(List<string>),
                Expression = new ConstantExpression {
                    Type = typeof(<closure>),
                    Value = #<closure>
                },
                Member = typeof(<closure>).GetField("lst")
            }
        },
        Method = typeof(Enumerable).GetMethod("Count", new[] { typeof(IEnumerable<string>) })
    },
    ReturnType = typeof(int)
}
---- CSCompiler.False
new Expression<Func<bool>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<bool>),
    Body = new ConstantExpression {
        Type = typeof(bool),
        Value = false
    },
    ReturnType = typeof(bool)
}
---- CSCompiler.GreaterThan
new Expression<Func<bool>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<bool>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.GreaterThan,
        Type = typeof(bool),
        Left = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("i")
        },
        Right = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("j")
        }
    },
    ReturnType = typeof(bool)
}
---- CSCompiler.GreaterThanOrEqual
new Expression<Func<bool>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<bool>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.GreaterThanOrEqual,
        Type = typeof(bool),
        Left = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("i")
        },
        Right = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("j")
        }
    },
    ReturnType = typeof(bool)
}
---- CSCompiler.InstanceMember
new Expression<Func<int>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<int>),
    Body = new MemberExpression {
        Type = typeof(int),
        Expression = new MemberExpression {
            Type = typeof(string),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("s")
        },
        Member = typeof(string).GetProperty("Length")
    },
    ReturnType = typeof(int)
}
---- CSCompiler.InstanceMethod0Arguments
new Expression<Func<string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string>),
    Body = new MethodCallExpression {
        Type = typeof(string),
        Object = new MemberExpression {
            Type = typeof(string),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("s")
        },
        Method = typeof(object).GetMethod("ToString")
    },
    ReturnType = typeof(string)
}
---- CSCompiler.InstanceMethod1Argument
new Expression<Func<int>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<int>),
    Body = new MethodCallExpression {
        Type = typeof(int),
        Object = new MemberExpression {
            Type = typeof(string),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("s")
        },
        Arguments = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(string)
            }
        },
        Method = typeof(string).GetMethod("CompareTo", new[] { typeof(string) })
    },
    ReturnType = typeof(int)
}
---- CSCompiler.InstanceMethod2Arguments
new Expression<Func<int>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<int>),
    Body = new MethodCallExpression {
        Type = typeof(int),
        Object = new MemberExpression {
            Type = typeof(string),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("s")
        },
        Arguments = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(char),
                Value = 'a'
            },
            new ConstantExpression {
                Type = typeof(int),
                Value = 2
            }
        },
        Method = typeof(string).GetMethod("IndexOf", new[] { typeof(char), typeof(int) })
    },
    ReturnType = typeof(int)
}
---- CSCompiler.Integer
new Expression<Func<int>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<int>),
    Body = new ConstantExpression {
        Type = typeof(int),
        Value = 5
    },
    ReturnType = typeof(int)
}
---- CSCompiler.InterpolatedString
new Expression<Func<string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string>),
    Body = new MethodCallExpression {
        Type = typeof(string),
        Arguments = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(string),
                Value = "{0:yyyy-MM-dd}"
            },
            new UnaryExpression {
                NodeType = ExpressionType.Convert,
                Type = typeof(object),
                Operand = new NewExpression {
                    Type = typeof(DateTime),
                    Arguments = new ReadOnlyCollection<Expression> {
                        new ConstantExpression {
                            Type = typeof(int),
                            Value = 2001
                        },
                        new ConstantExpression {
                            Type = typeof(int),
                            Value = 3
                        },
                        new ConstantExpression {
                            Type = typeof(int),
                            Value = 25
                        }
                    },
                    Constructor = typeof(DateTime).GetConstructor(new[] { typeof(int), typeof(int), typeof(int) })
                }
            }
        },
        Method = typeof(string).GetMethod("Format", new[] { typeof(string), typeof(object) })
    },
    ReturnType = typeof(string)
}
---- CSCompiler.InvocationNoArguments
new Expression<Func<int>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<int>),
    Body = new InvocationExpression {
        Type = typeof(int),
        Expression = new MemberExpression {
            Type = typeof(Func<int>),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("del")
        }
    },
    ReturnType = typeof(int)
}
---- CSCompiler.InvocationOneArgument
new Expression<Func<int>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<int>),
    Body = new InvocationExpression {
        Type = typeof(int),
        Arguments = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(int),
                Value = 5
            }
        },
        Expression = new MemberExpression {
            Type = typeof(Func<int, int>),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("del")
        }
    },
    ReturnType = typeof(int)
}
---- CSCompiler.JaggedWithBounds
new Expression<Func<string[][]>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string[][]>),
    Body = new NewArrayExpression {
        NodeType = ExpressionType.NewArrayBounds,
        Type = typeof(string[][]),
        Expressions = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(int),
                Value = 5
            }
        }
    },
    ReturnType = typeof(string[][])
}
---- CSCompiler.JaggedWithElementsExplicitType
new Expression<Func<object[][]>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<object[][]>),
    Body = new NewArrayExpression {
        NodeType = ExpressionType.NewArrayInit,
        Type = typeof(object[][]),
        Expressions = new ReadOnlyCollection<Expression> {
            new NewArrayExpression {
                NodeType = ExpressionType.NewArrayInit,
                Type = typeof(string[]),
                Expressions = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(string),
                        Value = "ab"
                    },
                    new ConstantExpression {
                        Type = typeof(string),
                        Value = "cd"
                    }
                }
            },
            new NewArrayExpression {
                NodeType = ExpressionType.NewArrayInit,
                Type = typeof(string[]),
                Expressions = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(string),
                        Value = "ef"
                    },
                    new ConstantExpression {
                        Type = typeof(string),
                        Value = "gh"
                    }
                }
            }
        }
    },
    ReturnType = typeof(object[][])
}
---- CSCompiler.JaggedWithElementsImplicitType
new Expression<Func<string[][]>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string[][]>),
    Body = new NewArrayExpression {
        NodeType = ExpressionType.NewArrayInit,
        Type = typeof(string[][]),
        Expressions = new ReadOnlyCollection<Expression> {
            new NewArrayExpression {
                NodeType = ExpressionType.NewArrayInit,
                Type = typeof(string[]),
                Expressions = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(string),
                        Value = "ab"
                    },
                    new ConstantExpression {
                        Type = typeof(string),
                        Value = "cd"
                    }
                }
            },
            new NewArrayExpression {
                NodeType = ExpressionType.NewArrayInit,
                Type = typeof(string[]),
                Expressions = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(string),
                        Value = "ef"
                    },
                    new ConstantExpression {
                        Type = typeof(string),
                        Value = "gh"
                    }
                }
            }
        }
    },
    ReturnType = typeof(string[][])
}
---- CSCompiler.LeftShift
new Expression<Func<int>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<int>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.LeftShift,
        Type = typeof(int),
        Left = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("i")
        },
        Right = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("j")
        }
    },
    ReturnType = typeof(int)
}
---- CSCompiler.LessThan
new Expression<Func<bool>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<bool>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.LessThan,
        Type = typeof(bool),
        Left = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("i")
        },
        Right = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("j")
        }
    },
    ReturnType = typeof(bool)
}
---- CSCompiler.LessThanOrEqual
new Expression<Func<bool>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<bool>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.LessThanOrEqual,
        Type = typeof(bool),
        Left = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("i")
        },
        Right = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("j")
        }
    },
    ReturnType = typeof(bool)
}
---- CSCompiler.ListBinding
new Expression<Func<Node>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<Node>),
    Body = new MemberInitExpression {
        Type = typeof(Node),
        NewExpression = new NewExpression {
            Type = typeof(Node),
            Constructor = typeof(Node).GetConstructor(new Type[] { })
        },
        Bindings = new ReadOnlyCollection<MemberBinding> {
            new MemberListBinding {
                BindingType = MemberBindingType.ListBinding,
                Initializers = new ReadOnlyCollection<ElementInit> {
                    new ElementInit {
                        AddMethod = typeof(ICollection<Node>).GetMethod("Add"),
                        Arguments = new ReadOnlyCollection<Expression> {
                            new NewExpression {
                                Type = typeof(Node),
                                Constructor = typeof(Node).GetConstructor(new Type[] { })
                            }
                        }
                    },
                    new ElementInit {
                        AddMethod = typeof(ICollection<Node>).GetMethod("Add"),
                        Arguments = new ReadOnlyCollection<Expression> {
                            new NewExpression {
                                Type = typeof(Node),
                                Constructor = typeof(Node).GetConstructor(new Type[] { })
                            }
                        }
                    }
                },
                Member = typeof(Node).GetProperty("Children", BindingFlags.Instance | BindingFlags.NonPublic)
            }
        }
    },
    ReturnType = typeof(Node)
}
---- CSCompiler.LogicalNot
new Expression<Func<bool>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<bool>),
    Body = new UnaryExpression {
        NodeType = ExpressionType.Not,
        Type = typeof(bool),
        Operand = new MemberExpression {
            Type = typeof(bool),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("b")
        }
    },
    ReturnType = typeof(bool)
}
---- CSCompiler.MathPow
var x = new ParameterExpression {
    Type = typeof(double),
    IsByRef = false,
    Name = "x"
};
var y = new ParameterExpression {
    Type = typeof(double),
    IsByRef = false,
    Name = "y"
};

new Expression<Func<double, double, double>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<double, double, double>),
    Parameters = new ReadOnlyCollection<ParameterExpression> {
        x,
        y
    },
    Body = new MethodCallExpression {
        Type = typeof(double),
        Arguments = new ReadOnlyCollection<Expression> {
            x,
            y
        },
        Method = typeof(Math).GetMethod("Pow")
    },
    ReturnType = typeof(double)
}
---- CSCompiler.MemberMemberBinding
new Expression<Func<Node>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<Node>),
    Body = new MemberInitExpression {
        Type = typeof(Node),
        NewExpression = new NewExpression {
            Type = typeof(Node),
            Constructor = typeof(Node).GetConstructor(new Type[] { })
        },
        Bindings = new ReadOnlyCollection<MemberBinding> {
            new MemberMemberBinding {
                Bindings = new ReadOnlyCollection<MemberBinding> {
                    new MemberAssignment {
                        BindingType = MemberBindingType.Assignment,
                        Expression = new ConstantExpression {
                            Type = typeof(string),
                            Value = "abcd"
                        },
                        Member = typeof(NodeData).GetProperty("Name", BindingFlags.Instance | BindingFlags.NonPublic)
                    }
                },
                BindingType = MemberBindingType.MemberBinding,
                Member = typeof(Node).GetProperty("Data", BindingFlags.Instance | BindingFlags.NonPublic)
            }
        }
    },
    ReturnType = typeof(Node)
}
---- CSCompiler.Modulo
new Expression<Func<double>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<double>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.Modulo,
        Type = typeof(double),
        Left = new MemberExpression {
            Type = typeof(double),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("x")
        },
        Right = new MemberExpression {
            Type = typeof(double),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("y")
        }
    },
    ReturnType = typeof(double)
}
---- CSCompiler.MultidimensionalArrayOfArray
new Expression<Func<string[,][]>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string[,][]>),
    Body = new NewArrayExpression {
        NodeType = ExpressionType.NewArrayBounds,
        Type = typeof(string[,][]),
        Expressions = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(int),
                Value = 3
            },
            new ConstantExpression {
                Type = typeof(int),
                Value = 2
            }
        }
    },
    ReturnType = typeof(string[,][])
}
---- CSCompiler.MultidimensionWithBounds
new Expression<Func<string[,]>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string[,]>),
    Body = new NewArrayExpression {
        NodeType = ExpressionType.NewArrayBounds,
        Type = typeof(string[,]),
        Expressions = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(int),
                Value = 2
            },
            new ConstantExpression {
                Type = typeof(int),
                Value = 3
            }
        }
    },
    ReturnType = typeof(string[,])
}
---- CSCompiler.Multiply
new Expression<Func<double>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<double>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.Multiply,
        Type = typeof(double),
        Left = new MemberExpression {
            Type = typeof(double),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("x")
        },
        Right = new MemberExpression {
            Type = typeof(double),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("y")
        }
    },
    ReturnType = typeof(double)
}
---- CSCompiler.NamedType
new Expression<Func<Random>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<Random>),
    Body = new NewExpression {
        Type = typeof(Random),
        Constructor = typeof(Random).GetConstructor(new Type[] { })
    },
    ReturnType = typeof(Random)
}
---- CSCompiler.NamedTypeConstructorParameters
new Expression<Func<Foo>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<Foo>),
    Body = new NewExpression {
        Type = typeof(Foo),
        Arguments = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(string),
                Value = "ijkl"
            }
        },
        Constructor = typeof(Foo).GetConstructor(new[] { typeof(string) })
    },
    ReturnType = typeof(Foo)
}
---- CSCompiler.NamedTypeConstructorParametersWithInitializers
new Expression<Func<Foo>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<Foo>),
    Body = new MemberInitExpression {
        Type = typeof(Foo),
        NewExpression = new NewExpression {
            Type = typeof(Foo),
            Arguments = new ReadOnlyCollection<Expression> {
                new ConstantExpression {
                    Type = typeof(string),
                    Value = "ijkl"
                }
            },
            Constructor = typeof(Foo).GetConstructor(new[] { typeof(string) })
        },
        Bindings = new ReadOnlyCollection<MemberBinding> {
            new MemberAssignment {
                BindingType = MemberBindingType.Assignment,
                Expression = new ConstantExpression {
                    Type = typeof(string),
                    Value = "abcd"
                },
                Member = typeof(Foo).GetProperty("Bar")
            },
            new MemberAssignment {
                BindingType = MemberBindingType.Assignment,
                Expression = new ConstantExpression {
                    Type = typeof(string),
                    Value = "efgh"
                },
                Member = typeof(Foo).GetProperty("Baz")
            }
        }
    },
    ReturnType = typeof(Foo)
}
---- CSCompiler.NamedTypeWithInitializer
new Expression<Func<Foo>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<Foo>),
    Body = new MemberInitExpression {
        Type = typeof(Foo),
        NewExpression = new NewExpression {
            Type = typeof(Foo),
            Constructor = typeof(Foo).GetConstructor(new Type[] { })
        },
        Bindings = new ReadOnlyCollection<MemberBinding> {
            new MemberAssignment {
                BindingType = MemberBindingType.Assignment,
                Expression = new ConstantExpression {
                    Type = typeof(string),
                    Value = "abcd"
                },
                Member = typeof(Foo).GetProperty("Bar")
            }
        }
    },
    ReturnType = typeof(Foo)
}
---- CSCompiler.NamedTypeWithInitializers
new Expression<Func<Foo>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<Foo>),
    Body = new MemberInitExpression {
        Type = typeof(Foo),
        NewExpression = new NewExpression {
            Type = typeof(Foo),
            Constructor = typeof(Foo).GetConstructor(new Type[] { })
        },
        Bindings = new ReadOnlyCollection<MemberBinding> {
            new MemberAssignment {
                BindingType = MemberBindingType.Assignment,
                Expression = new ConstantExpression {
                    Type = typeof(string),
                    Value = "abcd"
                },
                Member = typeof(Foo).GetProperty("Bar")
            },
            new MemberAssignment {
                BindingType = MemberBindingType.Assignment,
                Expression = new ConstantExpression {
                    Type = typeof(string),
                    Value = "efgh"
                },
                Member = typeof(Foo).GetProperty("Baz")
            }
        }
    },
    ReturnType = typeof(Foo)
}
---- CSCompiler.Negate
new Expression<Func<int>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<int>),
    Body = new UnaryExpression {
        NodeType = ExpressionType.Negate,
        Type = typeof(int),
        Operand = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("i")
        }
    },
    ReturnType = typeof(int)
}
---- CSCompiler.NonInteger
new Expression<Func<double>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<double>),
    Body = new ConstantExpression {
        Type = typeof(double),
        Value = 7.32
    },
    ReturnType = typeof(double)
}
---- CSCompiler.NoParametersNonVoidReturn
new Expression<Func<string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string>),
    Body = new ConstantExpression {
        Type = typeof(string),
        Value = "abcd"
    },
    ReturnType = typeof(string)
}
---- CSCompiler.NoParametersVoidReturn
new Expression<Action> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Action),
    Body = new MethodCallExpression {
        Type = typeof(void),
        Method = typeof(Console).GetMethod("WriteLine", new Type[] { })
    },
    ReturnType = typeof(void)
}
---- CSCompiler.NotEqual
new Expression<Func<bool>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<bool>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.NotEqual,
        Type = typeof(bool),
        Left = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("i")
        },
        Right = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("j")
        }
    },
    ReturnType = typeof(bool)
}
---- CSCompiler.Nothing
new Expression<Func<string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string>),
    Body = new ConstantExpression {
        Type = typeof(string)
    },
    ReturnType = typeof(string)
}
---- CSCompiler.OneParameterNonVoidReturn
var s = new ParameterExpression {
    Type = typeof(string),
    IsByRef = false,
    Name = "s"
};

new Expression<Func<string, string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string, string>),
    Parameters = new ReadOnlyCollection<ParameterExpression> {
        s
    },
    Body = s,
    ReturnType = typeof(string)
}
---- CSCompiler.OneParameterVoidReturn
var s = new ParameterExpression {
    Type = typeof(string),
    IsByRef = false,
    Name = "s"
};

new Expression<Action<string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Action<string>),
    Parameters = new ReadOnlyCollection<ParameterExpression> {
        s
    },
    Body = new MethodCallExpression {
        Type = typeof(void),
        Arguments = new ReadOnlyCollection<Expression> {
            s
        },
        Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(string) })
    },
    ReturnType = typeof(void)
}
---- CSCompiler.OrBitwise
new Expression<Func<int>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<int>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.Or,
        Type = typeof(int),
        Left = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("i")
        },
        Right = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("j")
        }
    },
    ReturnType = typeof(int)
}
---- CSCompiler.OrElse
new Expression<Func<bool>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<bool>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.OrElse,
        Type = typeof(bool),
        Left = new MemberExpression {
            Type = typeof(bool),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("b1")
        },
        Right = new MemberExpression {
            Type = typeof(bool),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("b2")
        }
    },
    ReturnType = typeof(bool)
}
---- CSCompiler.OrLogical
new Expression<Func<bool>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<bool>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.Or,
        Type = typeof(bool),
        Left = new MemberExpression {
            Type = typeof(bool),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("b1")
        },
        Right = new MemberExpression {
            Type = typeof(bool),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("b2")
        }
    },
    ReturnType = typeof(bool)
}
---- CSCompiler.RightShift
new Expression<Func<int>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<int>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.RightShift,
        Type = typeof(int),
        Left = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("i")
        },
        Right = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("j")
        }
    },
    ReturnType = typeof(int)
}
---- CSCompiler.SingleDimensionInit
new Expression<Func<string[]>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string[]>),
    Body = new NewArrayExpression {
        NodeType = ExpressionType.NewArrayInit,
        Type = typeof(string[]),
        Expressions = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(string)
            }
        }
    },
    ReturnType = typeof(string[])
}
---- CSCompiler.SingleDimensionInitExplicitType
new Expression<Func<object[]>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<object[]>),
    Body = new NewArrayExpression {
        NodeType = ExpressionType.NewArrayInit,
        Type = typeof(object[]),
        Expressions = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(string)
            }
        }
    },
    ReturnType = typeof(object[])
}
---- CSCompiler.SingleDimensionWithBounds
new Expression<Func<string[]>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string[]>),
    Body = new NewArrayExpression {
        NodeType = ExpressionType.NewArrayBounds,
        Type = typeof(string[]),
        Expressions = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(int),
                Value = 5
            }
        }
    },
    ReturnType = typeof(string[])
}
---- CSCompiler.StaticMember
new Expression<Func<string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string>),
    Body = new MemberExpression {
        Type = typeof(string),
        Member = typeof(string).GetField("Empty")
    },
    ReturnType = typeof(string)
}
---- CSCompiler.StaticMethod0Arguments
new Expression<Action> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Action),
    Body = new MethodCallExpression {
        Type = typeof(void),
        Method = typeof(Dummy).GetMethod("DummyMethod")
    },
    ReturnType = typeof(void)
}
---- CSCompiler.StaticMethod1Argument
new Expression<Func<string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string>),
    Body = new MethodCallExpression {
        Type = typeof(string),
        Arguments = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(string)
            }
        },
        Method = typeof(string).GetMethod("Intern")
    },
    ReturnType = typeof(string)
}
---- CSCompiler.StaticMethod2Arguments
new Expression<Func<string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string>),
    Body = new MethodCallExpression {
        Type = typeof(string),
        Arguments = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(string),
                Value = ","
            },
            new NewArrayExpression {
                NodeType = ExpressionType.NewArrayInit,
                Type = typeof(string[]),
                Expressions = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(string),
                        Value = "a"
                    },
                    new ConstantExpression {
                        Type = typeof(string),
                        Value = "b"
                    }
                }
            }
        },
        Method = typeof(string).GetMethod("Join", 0, new[] { typeof(string), typeof(string[]) })
    },
    ReturnType = typeof(string)
}
---- CSCompiler.String
new Expression<Func<string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string>),
    Body = new ConstantExpression {
        Type = typeof(string),
        Value = "abcd"
    },
    ReturnType = typeof(string)
}
---- CSCompiler.StringConcat
var s1 = new ParameterExpression {
    Type = typeof(string),
    IsByRef = false,
    Name = "s1"
};
var s2 = new ParameterExpression {
    Type = typeof(string),
    IsByRef = false,
    Name = "s2"
};

new Expression<Func<string, string, string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string, string, string>),
    Parameters = new ReadOnlyCollection<ParameterExpression> {
        s1,
        s2
    },
    Body = new MethodCallExpression {
        Type = typeof(string),
        Arguments = new ReadOnlyCollection<Expression> {
            s1,
            s2
        },
        Method = typeof(string).GetMethod("Concat", 0, new[] { typeof(string), typeof(string) })
    },
    ReturnType = typeof(string)
}
---- CSCompiler.Subtract
new Expression<Func<double>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<double>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.Subtract,
        Type = typeof(double),
        Left = new MemberExpression {
            Type = typeof(double),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("x")
        },
        Right = new MemberExpression {
            Type = typeof(double),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("y")
        }
    },
    ReturnType = typeof(double)
}
---- CSCompiler.True
new Expression<Func<bool>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<bool>),
    Body = new ConstantExpression {
        Type = typeof(bool),
        Value = true
    },
    ReturnType = typeof(bool)
}
---- CSCompiler.TwoParametersNonVoidReturn
var s1 = new ParameterExpression {
    Type = typeof(string),
    IsByRef = false,
    Name = "s1"
};
var s2 = new ParameterExpression {
    Type = typeof(string),
    IsByRef = false,
    Name = "s2"
};

new Expression<Func<string, string, string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string, string, string>),
    Parameters = new ReadOnlyCollection<ParameterExpression> {
        s1,
        s2
    },
    Body = new BinaryExpression {
        NodeType = ExpressionType.Add,
        Type = typeof(string),
        Left = s1,
        Right = s2,
        Method = typeof(string).GetMethod("Concat", 0, new[] { typeof(string), typeof(string) })
    },
    ReturnType = typeof(string)
}
---- CSCompiler.TwoParametersVoidReturn
var s1 = new ParameterExpression {
    Type = typeof(string),
    IsByRef = false,
    Name = "s1"
};
var s2 = new ParameterExpression {
    Type = typeof(string),
    IsByRef = false,
    Name = "s2"
};

new Expression<Action<string, string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Action<string, string>),
    Parameters = new ReadOnlyCollection<ParameterExpression> {
        s1,
        s2
    },
    Body = new MethodCallExpression {
        Type = typeof(void),
        Arguments = new ReadOnlyCollection<Expression> {
            new BinaryExpression {
                NodeType = ExpressionType.Add,
                Type = typeof(string),
                Left = s1,
                Right = s2,
                Method = typeof(string).GetMethod("Concat", 0, new[] { typeof(string), typeof(string) })
            }
        },
        Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(string) })
    },
    ReturnType = typeof(void)
}
---- CSCompiler.Type
new Expression<Func<Type>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<Type>),
    Body = new ConstantExpression {
        Type = typeof(Type),
        Value = typeof(string)
    },
    ReturnType = typeof(Type)
}
---- CSCompiler.TypeAs
new Expression<Func<string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string>),
    Body = new UnaryExpression {
        NodeType = ExpressionType.TypeAs,
        Type = typeof(string),
        Operand = new MemberExpression {
            Type = typeof(object),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("o")
        }
    },
    ReturnType = typeof(string)
}
---- CSCompiler.TypeCheck
new Expression<Func<bool>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<bool>),
    Body = new TypeBinaryExpression {
        NodeType = ExpressionType.TypeIs,
        Type = typeof(bool),
        Expression = new MemberExpression {
            Type = typeof(object),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("o")
        },
        TypeOperand = typeof(string)
    },
    ReturnType = typeof(bool)
}
---- CSCompiler.TypeIndexer
new Expression<Func<string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string>),
    Body = new MethodCallExpression {
        Type = typeof(string),
        Object = new MemberExpression {
            Type = typeof(List<string>),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("lst")
        },
        Arguments = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(int),
                Value = 3
            }
        },
        Method = typeof(List<string>).GetMethod("get_Item")
    },
    ReturnType = typeof(string)
}
---- FactoryMethods.Array
new ConstantExpression {
    Type = typeof(object[]),
    Value = new[] { "abcd", 5, #Random }
}
---- FactoryMethods.ArrayOfMultidimensionalArray
new NewArrayExpression {
    NodeType = ExpressionType.NewArrayBounds,
    Type = typeof(string[][,]),
    Expressions = new ReadOnlyCollection<Expression> {
        new ConstantExpression {
            Type = typeof(int),
            Value = 5
        }
    }
}
---- FactoryMethods.BlockMultipleVariable
var i = new ParameterExpression {
    Type = typeof(int),
    IsByRef = false,
    Name = "i"
};
var s1 = new ParameterExpression {
    Type = typeof(string),
    IsByRef = false,
    Name = "s1"
};

new BlockExpression {
    Type = typeof(bool),
    Variables = new ReadOnlyCollection<ParameterExpression> {
        i,
        s1
    },
    Expressions = new ReadOnlyCollection<Expression> {
        new ConstantExpression {
            Type = typeof(bool),
            Value = true
        },
        new ConstantExpression {
            Type = typeof(bool),
            Value = true
        }
    },
    Result = new ConstantExpression {
        Type = typeof(bool),
        Value = true
    }
}
---- FactoryMethods.BlockNoVariables
new BlockExpression {
    Type = typeof(bool),
    Expressions = new ReadOnlyCollection<Expression> {
        new ConstantExpression {
            Type = typeof(bool),
            Value = true
        },
        new ConstantExpression {
            Type = typeof(bool),
            Value = true
        }
    },
    Result = new ConstantExpression {
        Type = typeof(bool),
        Value = true
    }
}
---- FactoryMethods.BlockSingleVariable
var i = new ParameterExpression {
    Type = typeof(int),
    IsByRef = false,
    Name = "i"
};

new BlockExpression {
    Type = typeof(bool),
    Variables = new ReadOnlyCollection<ParameterExpression> {
        i
    },
    Expressions = new ReadOnlyCollection<Expression> {
        new ConstantExpression {
            Type = typeof(bool),
            Value = true
        },
        new ConstantExpression {
            Type = typeof(bool),
            Value = true
        }
    },
    Result = new ConstantExpression {
        Type = typeof(bool),
        Value = true
    }
}
---- FactoryMethods.CollectionTypeWithInitializer
new ListInitExpression {
    Type = typeof(List<string>),
    NewExpression = new NewExpression {
        Type = typeof(List<string>),
        Constructor = typeof(List<string>).GetConstructor(new Type[] { })
    },
    Initializers = new ReadOnlyCollection<ElementInit> {
        new ElementInit {
            AddMethod = typeof(List<string>).GetMethod("Add"),
            Arguments = new ReadOnlyCollection<Expression> {
                new ConstantExpression {
                    Type = typeof(string),
                    Value = "abcd"
                }
            }
        },
        new ElementInit {
            AddMethod = typeof(List<string>).GetMethod("Add"),
            Arguments = new ReadOnlyCollection<Expression> {
                new ConstantExpression {
                    Type = typeof(string),
                    Value = "efgh"
                }
            }
        }
    }
}
---- FactoryMethods.CollectionTypeWithMultiElementInitializers
new ListInitExpression {
    Type = typeof(Wrapper),
    NewExpression = new NewExpression {
        Type = typeof(Wrapper),
        Constructor = typeof(Wrapper).GetConstructor(new Type[] { })
    },
    Initializers = new ReadOnlyCollection<ElementInit> {
        new ElementInit {
            AddMethod = typeof(Wrapper).GetMethod("Add", BindingFlags.Instance | BindingFlags.NonPublic),
            Arguments = new ReadOnlyCollection<Expression> {
                new ConstantExpression {
                    Type = typeof(string),
                    Value = "ab"
                },
                new ConstantExpression {
                    Type = typeof(string),
                    Value = "cd"
                }
            }
        },
        new ElementInit {
            AddMethod = typeof(Wrapper).GetMethod("Add", BindingFlags.Instance | BindingFlags.NonPublic),
            Arguments = new ReadOnlyCollection<Expression> {
                new ConstantExpression {
                    Type = typeof(string),
                    Value = "ef"
                },
                new ConstantExpression {
                    Type = typeof(string),
                    Value = "gh"
                }
            }
        }
    }
}
---- FactoryMethods.CollectionTypeWithSingleOrMultiElementInitializers
new ListInitExpression {
    Type = typeof(Wrapper),
    NewExpression = new NewExpression {
        Type = typeof(Wrapper),
        Constructor = typeof(Wrapper).GetConstructor(new Type[] { })
    },
    Initializers = new ReadOnlyCollection<ElementInit> {
        new ElementInit {
            AddMethod = typeof(Wrapper).GetMethod("Add", BindingFlags.Instance | BindingFlags.NonPublic),
            Arguments = new ReadOnlyCollection<Expression> {
                new ConstantExpression {
                    Type = typeof(string),
                    Value = "ab"
                },
                new ConstantExpression {
                    Type = typeof(string),
                    Value = "cd"
                }
            }
        },
        new ElementInit {
            AddMethod = typeof(List<string>).GetMethod("Add"),
            Arguments = new ReadOnlyCollection<Expression> {
                new ConstantExpression {
                    Type = typeof(string),
                    Value = "ef"
                }
            }
        }
    }
}
---- FactoryMethods.ConstructAdd
new BinaryExpression {
    NodeType = ExpressionType.Add,
    Type = typeof(double),
    Left = x,
    Right = y
}
---- FactoryMethods.ConstructAddAssign
new BinaryExpression {
    NodeType = ExpressionType.AddAssign,
    Type = typeof(int),
    Left = i,
    Right = j
}
---- FactoryMethods.ConstructAddAssignChecked
new BinaryExpression {
    NodeType = ExpressionType.AddAssignChecked,
    Type = typeof(int),
    Left = i,
    Right = j
}
---- FactoryMethods.ConstructAddChecked
new BinaryExpression {
    NodeType = ExpressionType.AddChecked,
    Type = typeof(double),
    Left = x,
    Right = y
}
---- FactoryMethods.ConstructAndAlso
new BinaryExpression {
    NodeType = ExpressionType.AndAlso,
    Type = typeof(bool),
    Left = b1,
    Right = b2
}
---- FactoryMethods.ConstructAndAssign
new BinaryExpression {
    NodeType = ExpressionType.AndAssign,
    Type = typeof(bool),
    Left = b1,
    Right = b2
}
---- FactoryMethods.ConstructAndBitwise
new BinaryExpression {
    NodeType = ExpressionType.And,
    Type = typeof(int),
    Left = i,
    Right = j
}
---- FactoryMethods.ConstructAndLogical
new BinaryExpression {
    NodeType = ExpressionType.And,
    Type = typeof(bool),
    Left = b1,
    Right = b2
}
---- FactoryMethods.ConstructArrayIndex
new BinaryExpression {
    NodeType = ExpressionType.ArrayIndex,
    Type = typeof(string),
    Left = arr,
    Right = i
}
---- FactoryMethods.ConstructArrayLength
new UnaryExpression {
    NodeType = ExpressionType.ArrayLength,
    Type = typeof(int),
    Operand = arr
}
---- FactoryMethods.ConstructAssign
new BinaryExpression {
    NodeType = ExpressionType.Assign,
    Type = typeof(double),
    Left = x,
    Right = new ConstantExpression {
        Type = typeof(double),
        Value = 5.2
    }
}
---- FactoryMethods.ConstructBitwiseNot
new UnaryExpression {
    NodeType = ExpressionType.Not,
    Type = typeof(int),
    Operand = i
}
---- FactoryMethods.ConstructCatchMultiStatement
new CatchBlock {
    Variable = ex,
    Body = new BlockExpression {
        Type = typeof(void),
        Expressions = new ReadOnlyCollection<Expression> {
            new MethodCallExpression {
                Type = typeof(void),
                Arguments = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(bool),
                        Value = true
                    }
                },
                Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
            },
            new MethodCallExpression {
                Type = typeof(void),
                Arguments = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(bool),
                        Value = true
                    }
                },
                Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
            }
        },
        Result = new MethodCallExpression {
            Type = typeof(void),
            Arguments = new ReadOnlyCollection<Expression> {
                new ConstantExpression {
                    Type = typeof(bool),
                    Value = true
                }
            },
            Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
        }
    },
    Test = typeof(Exception)
}
---- FactoryMethods.ConstructCatchMultiStatementWithFilter
new CatchBlock {
    Variable = ex,
    Filter = new ConstantExpression {
        Type = typeof(bool),
        Value = true
    },
    Body = new BlockExpression {
        Type = typeof(void),
        Expressions = new ReadOnlyCollection<Expression> {
            new MethodCallExpression {
                Type = typeof(void),
                Arguments = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(bool),
                        Value = true
                    }
                },
                Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
            },
            new MethodCallExpression {
                Type = typeof(void),
                Arguments = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(bool),
                        Value = true
                    }
                },
                Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
            }
        },
        Result = new MethodCallExpression {
            Type = typeof(void),
            Arguments = new ReadOnlyCollection<Expression> {
                new ConstantExpression {
                    Type = typeof(bool),
                    Value = true
                }
            },
            Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
        }
    },
    Test = typeof(Exception)
}
---- FactoryMethods.ConstructCatchMultiStatementWithType
new CatchBlock {
    Body = new BlockExpression {
        Type = typeof(void),
        Expressions = new ReadOnlyCollection<Expression> {
            new MethodCallExpression {
                Type = typeof(void),
                Arguments = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(bool),
                        Value = true
                    }
                },
                Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
            },
            new MethodCallExpression {
                Type = typeof(void),
                Arguments = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(bool),
                        Value = true
                    }
                },
                Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
            }
        },
        Result = new MethodCallExpression {
            Type = typeof(void),
            Arguments = new ReadOnlyCollection<Expression> {
                new ConstantExpression {
                    Type = typeof(bool),
                    Value = true
                }
            },
            Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
        }
    },
    Test = typeof(InvalidCastException)
}
---- FactoryMethods.ConstructCatchSingleStatement
new CatchBlock {
    Variable = ex,
    Body = new MethodCallExpression {
        Type = typeof(void),
        Arguments = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(bool),
                Value = true
            }
        },
        Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
    },
    Test = typeof(Exception)
}
---- FactoryMethods.ConstructCatchSingleStatementWithFilter
new CatchBlock {
    Variable = ex,
    Filter = new ConstantExpression {
        Type = typeof(bool),
        Value = true
    },
    Body = new MethodCallExpression {
        Type = typeof(void),
        Arguments = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(bool),
                Value = true
            }
        },
        Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
    },
    Test = typeof(Exception)
}
---- FactoryMethods.ConstructCatchSingleStatementWithType
new CatchBlock {
    Body = new MethodCallExpression {
        Type = typeof(void),
        Arguments = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(bool),
                Value = true
            }
        },
        Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
    },
    Test = typeof(InvalidCastException)
}
---- FactoryMethods.ConstructCatchWithMultiStatementFilter
new CatchBlock {
    Variable = ex,
    Filter = new BlockExpression {
        Type = typeof(bool),
        Expressions = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(bool),
                Value = true
            },
            new ConstantExpression {
                Type = typeof(bool),
                Value = true
            }
        },
        Result = new ConstantExpression {
            Type = typeof(bool),
            Value = true
        }
    },
    Body = new MethodCallExpression {
        Type = typeof(void),
        Arguments = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(bool),
                Value = true
            }
        },
        Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
    },
    Test = typeof(Exception)
}
---- FactoryMethods.ConstructCoalesce
new BinaryExpression {
    NodeType = ExpressionType.Coalesce,
    Type = typeof(string),
    Left = s1,
    Right = s2
}
---- FactoryMethods.ConstructConvert
new UnaryExpression {
    NodeType = ExpressionType.Convert,
    Type = typeof(object),
    Operand = arr
}
---- FactoryMethods.ConstructConvertChecked
new UnaryExpression {
    NodeType = ExpressionType.ConvertChecked,
    Type = typeof(float),
    Operand = new ConstantExpression {
        Type = typeof(int),
        Value = 5
    }
}
---- FactoryMethods.ConstructConvertCheckedForReferenceType
new UnaryExpression {
    NodeType = ExpressionType.Convert,
    Type = typeof(object),
    Operand = arr
}
---- FactoryMethods.ConstructDecrement
new UnaryExpression {
    NodeType = ExpressionType.Decrement,
    Type = typeof(int),
    Operand = i
}
---- FactoryMethods.ConstructDivide
new BinaryExpression {
    NodeType = ExpressionType.Divide,
    Type = typeof(double),
    Left = x,
    Right = y
}
---- FactoryMethods.ConstructDivideAssign
new BinaryExpression {
    NodeType = ExpressionType.DivideAssign,
    Type = typeof(int),
    Left = i,
    Right = j
}
---- FactoryMethods.ConstructEmptyLabelTarget
new LabelTarget {
    Type = typeof(void)
}
---- FactoryMethods.ConstructEqual
new BinaryExpression {
    NodeType = ExpressionType.Equal,
    Type = typeof(bool),
    Left = x,
    Right = y
}
---- FactoryMethods.ConstructExclusiveOrAssign
new BinaryExpression {
    NodeType = ExpressionType.ExclusiveOrAssign,
    Type = typeof(bool),
    Left = b1,
    Right = b2
}
---- FactoryMethods.ConstructExclusiveOrBitwise
new BinaryExpression {
    NodeType = ExpressionType.ExclusiveOr,
    Type = typeof(int),
    Left = i,
    Right = j
}
---- FactoryMethods.ConstructExclusiveOrLogical
new BinaryExpression {
    NodeType = ExpressionType.ExclusiveOr,
    Type = typeof(bool),
    Left = b1,
    Right = b2
}
---- FactoryMethods.DynamicGetIndex
new DynamicExpression {
    Type = typeof(object),
    Binder = #CSharpGetIndexBinder,
    Arguments = new ReadOnlyCollection<Expression> {
        obj,
        new ConstantExpression {
            Type = typeof(string),
            Value = "key"
        }
    },
    DelegateType = typeof(Func<CallSite, object, string, object>)
}
---- FactoryMethods.DynamicGetIndexMultipleKeys
new DynamicExpression {
    Type = typeof(object),
    Binder = #CSharpGetIndexBinder,
    Arguments = new ReadOnlyCollection<Expression> {
        obj,
        new ConstantExpression {
            Type = typeof(string),
            Value = "key"
        },
        new ConstantExpression {
            Type = typeof(int),
            Value = 1
        }
    },
    DelegateType = typeof(Func<CallSite, object, string, int, object>)
}
---- FactoryMethods.DynamicGetMember
new DynamicExpression {
    Type = typeof(object),
    Binder = #CSharpGetMemberBinder,
    Arguments = new ReadOnlyCollection<Expression> {
        obj
    },
    DelegateType = typeof(Func<CallSite, object, object>)
}
---- FactoryMethods.ConstructGreaterThan
new BinaryExpression {
    NodeType = ExpressionType.GreaterThan,
    Type = typeof(bool),
    Left = x,
    Right = y
}
---- FactoryMethods.ConstructGreaterThanOrEqual
new BinaryExpression {
    NodeType = ExpressionType.GreaterThanOrEqual,
    Type = typeof(bool),
    Left = x,
    Right = y
}
---- FactoryMethods.ConstructIncrement
new UnaryExpression {
    NodeType = ExpressionType.Increment,
    Type = typeof(int),
    Operand = i
}
---- FactoryMethods.DynamicInvocationNoArguments
new DynamicExpression {
    Type = typeof(object),
    Binder = #CSharpInvokeBinder,
    Arguments = new ReadOnlyCollection<Expression> {
        obj
    },
    DelegateType = typeof(Func<CallSite, object, object>)
}
---- FactoryMethods.DynamicInvocationWithArguments
new DynamicExpression {
    Type = typeof(object),
    Binder = #CSharpInvokeBinder,
    Arguments = new ReadOnlyCollection<Expression> {
        obj,
        new ConstantExpression {
            Type = typeof(string),
            Value = "arg1"
        },
        new ConstantExpression {
            Type = typeof(int),
            Value = 15
        }
    },
    DelegateType = typeof(Func<CallSite, object, string, int, object>)
}
---- FactoryMethods.ConstructIsFalse
new UnaryExpression {
    NodeType = ExpressionType.IsFalse,
    Type = typeof(bool),
    Operand = b1
}
---- FactoryMethods.ConstructIsTrue
new UnaryExpression {
    NodeType = ExpressionType.IsTrue,
    Type = typeof(bool),
    Operand = b1
}
---- FactoryMethods.ConstructLabel
var i = new ParameterExpression {
    Type = typeof(int),
    IsByRef = false,
    Name = "i"
};
var j = new ParameterExpression {
    Type = typeof(int),
    IsByRef = false,
    Name = "j"
};
var j = new ParameterExpression {
    Type = typeof(int),
    IsByRef = false,
    Name = "j"
};

new BlockExpression {
    Type = typeof(bool),
    Variables = new ReadOnlyCollection<ParameterExpression> {
        i
    },
    Expressions = new ReadOnlyCollection<Expression> {
        new BlockExpression {
            Type = typeof(bool),
            Variables = new ReadOnlyCollection<ParameterExpression> {
                j
            },
            Expressions = new ReadOnlyCollection<Expression> {
                new ConstantExpression {
                    Type = typeof(bool),
                    Value = true
                },
                new LabelExpression {
                    Type = typeof(void),
                    Target = new LabelTarget {
                        Type = typeof(void),
                        Name = "target"
                    }
                },
                new ConstantExpression {
                    Type = typeof(bool),
                    Value = true
                }
            },
            Result = new ConstantExpression {
                Type = typeof(bool),
                Value = true
            }
        }
    },
    Result = new BlockExpression {
        Type = typeof(bool),
        Variables = new ReadOnlyCollection<ParameterExpression> {
            j
        },
        Expressions = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(bool),
                Value = true
            },
            new LabelExpression {
                Type = typeof(void),
                Target = new LabelTarget {
                    Type = typeof(void),
                    Name = "target"
                }
            },
            new ConstantExpression {
                Type = typeof(bool),
                Value = true
            }
        },
        Result = new ConstantExpression {
            Type = typeof(bool),
            Value = true
        }
    }
}
---- FactoryMethods.ConstructLabel1
var i = new ParameterExpression {
    Type = typeof(int),
    IsByRef = false,
    Name = "i"
};
var j = new ParameterExpression {
    Type = typeof(int),
    IsByRef = false,
    Name = "j"
};
var j = new ParameterExpression {
    Type = typeof(int),
    IsByRef = false,
    Name = "j"
};

new BlockExpression {
    Type = typeof(bool),
    Variables = new ReadOnlyCollection<ParameterExpression> {
        i
    },
    Expressions = new ReadOnlyCollection<Expression> {
        new BlockExpression {
            Type = typeof(bool),
            Variables = new ReadOnlyCollection<ParameterExpression> {
                j
            },
            Expressions = new ReadOnlyCollection<Expression> {
                new LabelExpression {
                    Type = typeof(void),
                    Target = new LabelTarget {
                        Type = typeof(void),
                        Name = "target"
                    }
                },
                new ConstantExpression {
                    Type = typeof(bool),
                    Value = true
                }
            },
            Result = new ConstantExpression {
                Type = typeof(bool),
                Value = true
            }
        }
    },
    Result = new BlockExpression {
        Type = typeof(bool),
        Variables = new ReadOnlyCollection<ParameterExpression> {
            j
        },
        Expressions = new ReadOnlyCollection<Expression> {
            new LabelExpression {
                Type = typeof(void),
                Target = new LabelTarget {
                    Type = typeof(void),
                    Name = "target"
                }
            },
            new ConstantExpression {
                Type = typeof(bool),
                Value = true
            }
        },
        Result = new ConstantExpression {
            Type = typeof(bool),
            Value = true
        }
    }
}
---- FactoryMethods.ConstructLabelTarget
new LabelTarget {
    Type = typeof(void),
    Name = "target"
}
---- FactoryMethods.ConstructLeftShift
new BinaryExpression {
    NodeType = ExpressionType.LeftShift,
    Type = typeof(int),
    Left = i,
    Right = j
}
---- FactoryMethods.ConstructLeftShiftAssign
new BinaryExpression {
    NodeType = ExpressionType.LeftShiftAssign,
    Type = typeof(int),
    Left = i,
    Right = j
}
---- FactoryMethods.ConstructLessThan
new BinaryExpression {
    NodeType = ExpressionType.LessThan,
    Type = typeof(bool),
    Left = x,
    Right = y
}
---- FactoryMethods.ConstructLessThanOrEqual
new BinaryExpression {
    NodeType = ExpressionType.LessThanOrEqual,
    Type = typeof(bool),
    Left = x,
    Right = y
}
---- FactoryMethods.ConstructLogicalNot
new UnaryExpression {
    NodeType = ExpressionType.Not,
    Type = typeof(bool),
    Operand = b1
}
---- FactoryMethods.DynamicMemberInvocationNoArguments
new DynamicExpression {
    Type = typeof(object),
    Binder = #CSharpInvokeMemberBinder,
    Arguments = new ReadOnlyCollection<Expression> {
        obj
    },
    DelegateType = typeof(Func<CallSite, object, object>)
}
---- FactoryMethods.DynamicMemberInvocationWithArguments
new DynamicExpression {
    Type = typeof(object),
    Binder = #CSharpInvokeMemberBinder,
    Arguments = new ReadOnlyCollection<Expression> {
        obj,
        new ConstantExpression {
            Type = typeof(string),
            Value = "arg1"
        },
        new ConstantExpression {
            Type = typeof(int),
            Value = 15
        }
    },
    DelegateType = typeof(Func<CallSite, object, string, int, object>)
}
---- FactoryMethods.ConstructModulo
new BinaryExpression {
    NodeType = ExpressionType.Modulo,
    Type = typeof(double),
    Left = x,
    Right = y
}
---- FactoryMethods.ConstructModuloAssign
new BinaryExpression {
    NodeType = ExpressionType.ModuloAssign,
    Type = typeof(int),
    Left = i,
    Right = j
}
---- FactoryMethods.ConstructMultiply
new BinaryExpression {
    NodeType = ExpressionType.Multiply,
    Type = typeof(double),
    Left = x,
    Right = y
}
---- FactoryMethods.ConstructMultiplyAssign
new BinaryExpression {
    NodeType = ExpressionType.MultiplyAssign,
    Type = typeof(int),
    Left = i,
    Right = j
}
---- FactoryMethods.ConstructMultiplyAssignChecked
new BinaryExpression {
    NodeType = ExpressionType.MultiplyAssignChecked,
    Type = typeof(int),
    Left = i,
    Right = j
}
---- FactoryMethods.ConstructMultiplyChecked
new BinaryExpression {
    NodeType = ExpressionType.MultiplyChecked,
    Type = typeof(double),
    Left = x,
    Right = y
}
---- FactoryMethods.ConstructNegate
new UnaryExpression {
    NodeType = ExpressionType.Negate,
    Type = typeof(int),
    Operand = i
}
---- FactoryMethods.ConstructNotEqual
new BinaryExpression {
    NodeType = ExpressionType.NotEqual,
    Type = typeof(bool),
    Left = x,
    Right = y
}
---- FactoryMethods.ConstructOrAssign
new BinaryExpression {
    NodeType = ExpressionType.OrAssign,
    Type = typeof(bool),
    Left = b1,
    Right = b2
}
---- FactoryMethods.ConstructOrBitwise
new BinaryExpression {
    NodeType = ExpressionType.Or,
    Type = typeof(int),
    Left = i,
    Right = j
}
---- FactoryMethods.ConstructOrElse
new BinaryExpression {
    NodeType = ExpressionType.OrElse,
    Type = typeof(bool),
    Left = b1,
    Right = b2
}
---- FactoryMethods.ConstructOrLogical
new BinaryExpression {
    NodeType = ExpressionType.Or,
    Type = typeof(bool),
    Left = b1,
    Right = b2
}
---- FactoryMethods.ConstructPostDecrementAssign
new UnaryExpression {
    NodeType = ExpressionType.PostDecrementAssign,
    Type = typeof(int),
    Operand = i
}
---- FactoryMethods.ConstructPostIncrementAssign
new UnaryExpression {
    NodeType = ExpressionType.PostIncrementAssign,
    Type = typeof(int),
    Operand = i
}
---- FactoryMethods.ConstructPower
new BinaryExpression {
    NodeType = ExpressionType.Power,
    Type = typeof(double),
    Left = x,
    Right = y,
    Method = typeof(Math).GetMethod("Pow")
}
---- FactoryMethods.ConstructPowerAssign
new BinaryExpression {
    NodeType = ExpressionType.PowerAssign,
    Type = typeof(double),
    Left = x,
    Right = y,
    Method = typeof(Math).GetMethod("Pow")
}
---- FactoryMethods.ConstructPreDecrementAssign
new UnaryExpression {
    NodeType = ExpressionType.PreDecrementAssign,
    Type = typeof(int),
    Operand = i
}
---- FactoryMethods.ConstructPreIncrementAssign
new UnaryExpression {
    NodeType = ExpressionType.PreIncrementAssign,
    Type = typeof(int),
    Operand = i
}
---- FactoryMethods.ConstructReferenceEqual
new BinaryExpression {
    NodeType = ExpressionType.Equal,
    Type = typeof(bool),
    Left = lstString,
    Right = lstString
}
---- FactoryMethods.ConstructReferenceNotEqual
new BinaryExpression {
    NodeType = ExpressionType.NotEqual,
    Type = typeof(bool),
    Left = lstString,
    Right = lstString
}
---- FactoryMethods.ConstructRethrow
new UnaryExpression {
    NodeType = ExpressionType.Throw,
    Type = typeof(void)
}
---- FactoryMethods.ConstructRightShift
new BinaryExpression {
    NodeType = ExpressionType.RightShift,
    Type = typeof(int),
    Left = i,
    Right = j
}
---- FactoryMethods.ConstructRightShiftAssign
new BinaryExpression {
    NodeType = ExpressionType.RightShiftAssign,
    Type = typeof(int),
    Left = i,
    Right = j
}
---- FactoryMethods.ConstructRuntimeVariables
new RuntimeVariablesExpression {
    Type = typeof(IRuntimeVariables),
    Variables = new ReadOnlyCollection<ParameterExpression> {
        x,
        s1
    }
}
---- FactoryMethods.DynamicSetIndex
new DynamicExpression {
    Type = typeof(object),
    Binder = #CSharpSetIndexBinder,
    Arguments = new ReadOnlyCollection<Expression> {
        obj,
        new ConstantExpression {
            Type = typeof(int),
            Value = 42
        },
        new ConstantExpression {
            Type = typeof(string),
            Value = "key"
        }
    },
    DelegateType = typeof(Func<CallSite, object, int, string, object>)
}
---- FactoryMethods.DynamicSetIndexMultipleKeys
new DynamicExpression {
    Type = typeof(object),
    Binder = #CSharpSetIndexBinder,
    Arguments = new ReadOnlyCollection<Expression> {
        obj,
        new ConstantExpression {
            Type = typeof(int),
            Value = 42
        },
        new ConstantExpression {
            Type = typeof(string),
            Value = "key"
        },
        new ConstantExpression {
            Type = typeof(int),
            Value = 1
        }
    },
    DelegateType = typeof(Func<CallSite, object, int, string, int, object>)
}
---- FactoryMethods.DynamicSetMember
new DynamicExpression {
    Type = typeof(object),
    Binder = #CSharpSetMemberBinder,
    Arguments = new ReadOnlyCollection<Expression> {
        obj,
        new ConstantExpression {
            Type = typeof(int),
            Value = 42
        }
    },
    DelegateType = typeof(Func<CallSite, object, int, object>)
}
---- FactoryMethods.ConstructSimpleCatch
new CatchBlock {
    Body = new MethodCallExpression {
        Type = typeof(void),
        Arguments = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(bool),
                Value = true
            }
        },
        Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
    },
    Test = typeof(Exception)
}
---- FactoryMethods.ConstructSubtract
new BinaryExpression {
    NodeType = ExpressionType.Subtract,
    Type = typeof(double),
    Left = x,
    Right = y
}
---- FactoryMethods.ConstructSubtractAssign
new BinaryExpression {
    NodeType = ExpressionType.SubtractAssign,
    Type = typeof(int),
    Left = i,
    Right = j
}
---- FactoryMethods.ConstructSubtractAssignChecked
new BinaryExpression {
    NodeType = ExpressionType.SubtractAssignChecked,
    Type = typeof(int),
    Left = i,
    Right = j
}
---- FactoryMethods.ConstructSubtractChecked
new BinaryExpression {
    NodeType = ExpressionType.SubtractChecked,
    Type = typeof(double),
    Left = x,
    Right = y
}
---- FactoryMethods.ConstructThrow
new UnaryExpression {
    NodeType = ExpressionType.Throw,
    Type = typeof(void),
    Operand = new ConstantExpression {
        Type = typeof(Random),
        Value = #Random
    }
}
---- FactoryMethods.ConstructTryCatch
new TryExpression {
    Type = typeof(bool),
    Body = new ConstantExpression {
        Type = typeof(bool),
        Value = true
    },
    Handlers = new ReadOnlyCollection<CatchBlock> {
        new CatchBlock {
            Body = new ConstantExpression {
                Type = typeof(bool),
                Value = true
            },
            Test = typeof(Exception)
        }
    }
}
---- FactoryMethods.ConstructTryCatchFinally
new TryExpression {
    Type = typeof(bool),
    Body = new ConstantExpression {
        Type = typeof(bool),
        Value = true
    },
    Handlers = new ReadOnlyCollection<CatchBlock> {
        new CatchBlock {
            Variable = ex,
            Body = new ConstantExpression {
                Type = typeof(bool),
                Value = true
            },
            Test = typeof(Exception)
        }
    },
    Finally = new MethodCallExpression {
        Type = typeof(void),
        Arguments = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(bool),
                Value = true
            }
        },
        Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
    }
}
---- FactoryMethods.ConstructTryFault
new TryExpression {
    Type = typeof(void),
    Body = new MethodCallExpression {
        Type = typeof(void),
        Arguments = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(bool),
                Value = true
            }
        },
        Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
    },
    Fault = new MethodCallExpression {
        Type = typeof(void),
        Arguments = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(bool),
                Value = true
            }
        },
        Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
    }
}
---- FactoryMethods.ConstructTryFinally
new TryExpression {
    Type = typeof(void),
    Body = new MethodCallExpression {
        Type = typeof(void),
        Arguments = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(bool),
                Value = true
            }
        },
        Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
    },
    Finally = new MethodCallExpression {
        Type = typeof(void),
        Arguments = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(bool),
                Value = true
            }
        },
        Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
    }
}
---- FactoryMethods.ConstructTypeAs
new UnaryExpression {
    NodeType = ExpressionType.TypeAs,
    Type = typeof(object),
    Operand = arr
}
---- FactoryMethods.DifferentTypeForNodeAndValue
new ConstantExpression {
    Type = typeof(IEnumerable)
}
---- FactoryMethods.EmptyLoop
new LoopExpression {
    Type = typeof(void),
    Body = new ConstantExpression {
        Type = typeof(bool),
        Value = true
    }
}
---- FactoryMethods.EmptyLoop1
new LoopExpression {
    Type = typeof(void),
    Body = new BlockExpression {
        Type = typeof(bool),
        Expressions = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(bool),
                Value = true
            },
            new ConstantExpression {
                Type = typeof(bool),
                Value = true
            }
        },
        Result = new ConstantExpression {
            Type = typeof(bool),
            Value = true
        }
    }
}
---- FactoryMethods.ExtensionMethod0Arguments
new MethodCallExpression {
    Type = typeof(int),
    Arguments = new ReadOnlyCollection<Expression> {
        lstString
    },
    Method = typeof(Enumerable).GetMethod("Count", new[] { typeof(IEnumerable<string>) })
}
---- FactoryMethods.InstanceIndexer
new IndexExpression {
    Type = typeof(string),
    Object = lstString,
    Arguments = new ReadOnlyCollection<Expression> {
        new ConstantExpression {
            Type = typeof(int),
            Value = 0
        }
    },
    Indexer = typeof(List<string>).GetProperty("Item")
}
---- FactoryMethods.InstanceMember
new MemberExpression {
    Type = typeof(int),
    Expression = new ConstantExpression {
        Type = typeof(string)
    },
    Member = typeof(string).GetProperty("Length")
}
---- FactoryMethods.InstanceMethod0Arguments
new MethodCallExpression {
    Type = typeof(string),
    Object = s,
    Method = typeof(object).GetMethod("ToString")
}
---- FactoryMethods.InstanceMethod1Argument
new MethodCallExpression {
    Type = typeof(int),
    Object = s,
    Arguments = new ReadOnlyCollection<Expression> {
        new ConstantExpression {
            Type = typeof(string)
        }
    },
    Method = typeof(string).GetMethod("CompareTo", new[] { typeof(string) })
}
---- FactoryMethods.InstanceMethod2Arguments
new MethodCallExpression {
    Type = typeof(int),
    Object = s,
    Arguments = new ReadOnlyCollection<Expression> {
        new ConstantExpression {
            Type = typeof(char),
            Value = 'a'
        },
        new ConstantExpression {
            Type = typeof(int),
            Value = 2
        }
    },
    Method = typeof(string).GetMethod("IndexOf", new[] { typeof(char), typeof(int) })
}
---- FactoryMethods.JaggedWithBounds
new NewArrayExpression {
    NodeType = ExpressionType.NewArrayBounds,
    Type = typeof(string[][]),
    Expressions = new ReadOnlyCollection<Expression> {
        new ConstantExpression {
            Type = typeof(int),
            Value = 5
        }
    }
}
---- FactoryMethods.JaggedWithElementsExplicitType
new NewArrayExpression {
    NodeType = ExpressionType.NewArrayInit,
    Type = typeof(object[][]),
    Expressions = new ReadOnlyCollection<Expression> {
        new NewArrayExpression {
            NodeType = ExpressionType.NewArrayInit,
            Type = typeof(string[]),
            Expressions = new ReadOnlyCollection<Expression> {
                new ConstantExpression {
                    Type = typeof(string),
                    Value = "ab"
                },
                new ConstantExpression {
                    Type = typeof(string),
                    Value = "cd"
                }
            }
        },
        new NewArrayExpression {
            NodeType = ExpressionType.NewArrayInit,
            Type = typeof(string[]),
            Expressions = new ReadOnlyCollection<Expression> {
                new ConstantExpression {
                    Type = typeof(string),
                    Value = "ef"
                },
                new ConstantExpression {
                    Type = typeof(string),
                    Value = "gh"
                }
            }
        }
    }
}
---- FactoryMethods.JaggedWithElementsImplicitType
new NewArrayExpression {
    NodeType = ExpressionType.NewArrayInit,
    Type = typeof(string[][]),
    Expressions = new ReadOnlyCollection<Expression> {
        new NewArrayExpression {
            NodeType = ExpressionType.NewArrayInit,
            Type = typeof(string[]),
            Expressions = new ReadOnlyCollection<Expression> {
                new ConstantExpression {
                    Type = typeof(string),
                    Value = "ab"
                },
                new ConstantExpression {
                    Type = typeof(string),
                    Value = "cd"
                }
            }
        },
        new NewArrayExpression {
            NodeType = ExpressionType.NewArrayInit,
            Type = typeof(string[]),
            Expressions = new ReadOnlyCollection<Expression> {
                new ConstantExpression {
                    Type = typeof(string),
                    Value = "ef"
                },
                new ConstantExpression {
                    Type = typeof(string),
                    Value = "gh"
                }
            }
        }
    }
}
---- FactoryMethods.LambdaMultilineBlockNonvoidReturn
new Expression<Func<bool>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<bool>),
    Body = new BlockExpression {
        Type = typeof(bool),
        Expressions = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(bool),
                Value = true
            },
            new ConstantExpression {
                Type = typeof(bool),
                Value = true
            }
        },
        Result = new ConstantExpression {
            Type = typeof(bool),
            Value = true
        }
    },
    ReturnType = typeof(bool)
}
---- FactoryMethods.LambdaMultilineNestedBlockNonvoidReturn
var s1 = new ParameterExpression {
    Type = typeof(string),
    IsByRef = false,
    Name = "s1"
};
var s2 = new ParameterExpression {
    Type = typeof(string),
    IsByRef = false,
    Name = "s2"
};
var s1 = new ParameterExpression {
    Type = typeof(string),
    IsByRef = false,
    Name = "s1"
};
var s2 = new ParameterExpression {
    Type = typeof(string),
    IsByRef = false,
    Name = "s2"
};

new Expression<Func<bool>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<bool>),
    Body = new BlockExpression {
        Type = typeof(bool),
        Expressions = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(bool),
                Value = true
            },
            new BlockExpression {
                Type = typeof(bool),
                Variables = new ReadOnlyCollection<ParameterExpression> {
                    s1,
                    s2
                },
                Expressions = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(bool),
                        Value = true
                    },
                    new ConstantExpression {
                        Type = typeof(bool),
                        Value = true
                    }
                },
                Result = new ConstantExpression {
                    Type = typeof(bool),
                    Value = true
                }
            }
        },
        Result = new BlockExpression {
            Type = typeof(bool),
            Variables = new ReadOnlyCollection<ParameterExpression> {
                s1,
                s2
            },
            Expressions = new ReadOnlyCollection<Expression> {
                new ConstantExpression {
                    Type = typeof(bool),
                    Value = true
                },
                new ConstantExpression {
                    Type = typeof(bool),
                    Value = true
                }
            },
            Result = new ConstantExpression {
                Type = typeof(bool),
                Value = true
            }
        }
    },
    ReturnType = typeof(bool)
}
---- FactoryMethods.MakeArrayAccess
new IndexExpression {
    Type = typeof(string),
    Object = arr,
    Arguments = new ReadOnlyCollection<Expression> {
        new ConstantExpression {
            Type = typeof(int),
            Value = 0
        }
    }
}
---- FactoryMethods.MakeArrayIndex
new BinaryExpression {
    NodeType = ExpressionType.ArrayIndex,
    Type = typeof(string),
    Left = arr,
    Right = new ConstantExpression {
        Type = typeof(int),
        Value = 0
    }
}
---- FactoryMethods.MakeArrayMultipleIndex
new MethodCallExpression {
    Type = typeof(string),
    Object = arr2d,
    Arguments = new ReadOnlyCollection<Expression> {
        new ConstantExpression {
            Type = typeof(int),
            Value = 0
        },
        new ConstantExpression {
            Type = typeof(int),
            Value = 1
        }
    },
    Method = typeof(string[,]).GetMethod("Get")
}
---- FactoryMethods.MakeBreak
new GotoExpression {
    Type = typeof(void),
    Kind = GotoExpressionKind.Break,
    Target = new LabelTarget {
        Type = typeof(void),
        Name = "target"
    }
}
---- FactoryMethods.MakeBreakWithValue
new GotoExpression {
    Type = typeof(void),
    Kind = GotoExpressionKind.Break,
    Target = new LabelTarget {
        Type = typeof(void),
        Name = "target"
    },
    Value = new ConstantExpression {
        Type = typeof(int),
        Value = 5
    }
}
---- FactoryMethods.MakeClearDebugInfo
new DebugInfoExpression {
    Type = typeof(void),
    Document = #SymbolDocumentInfo,
    EndColumn = 0,
    EndLine = 16707566,
    IsClear = true,
    StartColumn = 0,
    StartLine = 16707566
}
---- FactoryMethods.MakeConditional
new ConditionalExpression {
    Type = typeof(int),
    Test = new BinaryExpression {
        NodeType = ExpressionType.GreaterThan,
        Type = typeof(bool),
        Left = i,
        Right = new ConstantExpression {
            Type = typeof(int),
            Value = 10
        }
    },
    IfTrue = i,
    IfFalse = new BinaryExpression {
        NodeType = ExpressionType.Add,
        Type = typeof(int),
        Left = i,
        Right = new ConstantExpression {
            Type = typeof(int),
            Value = 10
        }
    }
}
---- FactoryMethods.MakeContinue
new GotoExpression {
    Type = typeof(void),
    Kind = GotoExpressionKind.Continue,
    Target = new LabelTarget {
        Type = typeof(void),
        Name = "target"
    }
}
---- FactoryMethods.MakeDebugInfo
new DebugInfoExpression {
    Type = typeof(void),
    Document = #SymbolDocumentInfo,
    EndColumn = 4,
    EndLine = 3,
    IsClear = false,
    StartColumn = 2,
    StartLine = 1
}
---- FactoryMethods.MakeDefaultRefType
new DefaultExpression {
    Type = typeof(string)
}
---- FactoryMethods.MakeDefaultValueType
new DefaultExpression {
    Type = typeof(int)
}
---- FactoryMethods.MakeElementInit
new ElementInit {
    AddMethod = typeof(List<string>).GetMethod("Add"),
    Arguments = new ReadOnlyCollection<Expression> {
        new ConstantExpression {
            Type = typeof(string),
            Value = "abcd"
        }
    }
}
---- FactoryMethods.MakeElementInit2Arguments
new ElementInit {
    AddMethod = typeof(Wrapper).GetMethod("Add", BindingFlags.Instance | BindingFlags.NonPublic),
    Arguments = new ReadOnlyCollection<Expression> {
        new ConstantExpression {
            Type = typeof(string),
            Value = "abcd"
        },
        new ConstantExpression {
            Type = typeof(string),
            Value = "efgh"
        }
    }
}
---- FactoryMethods.MakeGotoWithoutValue
new GotoExpression {
    Type = typeof(void),
    Kind = GotoExpressionKind.Goto,
    Target = new LabelTarget {
        Type = typeof(void),
        Name = "target"
    }
}
---- FactoryMethods.MakeGotoWithValue
new GotoExpression {
    Type = typeof(void),
    Kind = GotoExpressionKind.Goto,
    Target = new LabelTarget {
        Type = typeof(void),
        Name = "target"
    },
    Value = new ConstantExpression {
        Type = typeof(int),
        Value = 5
    }
}
---- FactoryMethods.MakeInvocation
new InvocationExpression {
    Type = typeof(int),
    Expression = new Expression<Func<int>> {
        NodeType = ExpressionType.Lambda,
        Type = typeof(Func<int>),
        Body = new ConstantExpression {
            Type = typeof(int),
            Value = 5
        },
        ReturnType = typeof(int)
    }
}
---- FactoryMethods.MakeListBinding
new MemberListBinding {
    BindingType = MemberBindingType.ListBinding,
    Initializers = new ReadOnlyCollection<ElementInit> {
        new ElementInit {
            AddMethod = typeof(ICollection<Node>).GetMethod("Add"),
            Arguments = new ReadOnlyCollection<Expression> {
                new NewExpression {
                    Type = typeof(Node),
                    Constructor = typeof(Node).GetConstructor(new Type[] { })
                }
            }
        },
        new ElementInit {
            AddMethod = typeof(ICollection<Node>).GetMethod("Add"),
            Arguments = new ReadOnlyCollection<Expression> {
                new NewExpression {
                    Type = typeof(Node),
                    Constructor = typeof(Node).GetConstructor(new Type[] { })
                }
            }
        }
    },
    Member = typeof(Node).GetProperty("Children", BindingFlags.Instance | BindingFlags.NonPublic)
}
---- FactoryMethods.MakeMemberBind
new MemberAssignment {
    BindingType = MemberBindingType.Assignment,
    Expression = new ConstantExpression {
        Type = typeof(string),
        Value = "abcd"
    },
    Member = typeof(DummyMember).GetProperty("Foo", BindingFlags.Instance | BindingFlags.NonPublic)
}
---- FactoryMethods.MakeMemberMemberBind
new MemberMemberBinding {
    Bindings = new ReadOnlyCollection<MemberBinding> {
        new MemberAssignment {
            BindingType = MemberBindingType.Assignment,
            Expression = new ConstantExpression {
                Type = typeof(string),
                Value = "abcd"
            },
            Member = typeof(NodeData).GetProperty("Name", BindingFlags.Instance | BindingFlags.NonPublic)
        }
    },
    BindingType = MemberBindingType.MemberBinding,
    Member = typeof(Node).GetProperty("Data", BindingFlags.Instance | BindingFlags.NonPublic)
}
---- FactoryMethods.MakeQuoted
var x = new ParameterExpression {
    Type = typeof(double),
    IsByRef = false,
    Name = "x"
};

new BlockExpression {
    Type = typeof(Expression<Action>),
    Variables = new ReadOnlyCollection<ParameterExpression> {
        x
    },
    Expressions = new ReadOnlyCollection<Expression> {
        new UnaryExpression {
            NodeType = ExpressionType.Quote,
            Type = typeof(Expression<Action>),
            Operand = new Expression<Action> {
                NodeType = ExpressionType.Lambda,
                Type = typeof(Action),
                Body = new MethodCallExpression {
                    Type = typeof(void),
                    Arguments = new ReadOnlyCollection<Expression> {
                        new ConstantExpression {
                            Type = typeof(bool),
                            Value = true
                        }
                    },
                    Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
                },
                ReturnType = typeof(void)
            }
        }
    },
    Result = new UnaryExpression {
        NodeType = ExpressionType.Quote,
        Type = typeof(Expression<Action>),
        Operand = new Expression<Action> {
            NodeType = ExpressionType.Lambda,
            Type = typeof(Action),
            Body = new MethodCallExpression {
                Type = typeof(void),
                Arguments = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(bool),
                        Value = true
                    }
                },
                Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
            },
            ReturnType = typeof(void)
        }
    }
}
---- FactoryMethods.MakeQuoted1
new Expression<Func<Expression<Action>>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<Expression<Action>>),
    Body = new UnaryExpression {
        NodeType = ExpressionType.Quote,
        Type = typeof(Expression<Action>),
        Operand = new Expression<Action> {
            NodeType = ExpressionType.Lambda,
            Type = typeof(Action),
            Body = new MethodCallExpression {
                Type = typeof(void),
                Arguments = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(bool),
                        Value = true
                    }
                },
                Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
            },
            ReturnType = typeof(void)
        }
    },
    ReturnType = typeof(Expression<Action>)
}
---- FactoryMethods.MakeReturn
new GotoExpression {
    Type = typeof(void),
    Kind = GotoExpressionKind.Return,
    Target = new LabelTarget {
        Type = typeof(void),
        Name = "target"
    }
}
---- FactoryMethods.MakeReturnWithValue
new GotoExpression {
    Type = typeof(void),
    Kind = GotoExpressionKind.Return,
    Target = new LabelTarget {
        Type = typeof(void),
        Name = "target"
    },
    Value = new ConstantExpression {
        Type = typeof(int),
        Value = 5
    }
}
---- FactoryMethods.MakeTypeCheck
new TypeBinaryExpression {
    NodeType = ExpressionType.TypeIs,
    Type = typeof(bool),
    Expression = new ConstantExpression {
        Type = typeof(string)
    },
    TypeOperand = typeof(string)
}
---- FactoryMethods.MakeTypeEqual
new TypeBinaryExpression {
    NodeType = ExpressionType.TypeEqual,
    Type = typeof(bool),
    Expression = new ConstantExpression {
        Type = typeof(string)
    },
    TypeOperand = typeof(IEnumerable)
}
---- FactoryMethods.MultidimensionalArrayOfArray
new NewArrayExpression {
    NodeType = ExpressionType.NewArrayBounds,
    Type = typeof(string[,][]),
    Expressions = new ReadOnlyCollection<Expression> {
        new ConstantExpression {
            Type = typeof(int),
            Value = 3
        },
        new ConstantExpression {
            Type = typeof(int),
            Value = 2
        }
    }
}
---- FactoryMethods.MultidimensionWithBounds
new NewArrayExpression {
    NodeType = ExpressionType.NewArrayBounds,
    Type = typeof(string[,]),
    Expressions = new ReadOnlyCollection<Expression> {
        new ConstantExpression {
            Type = typeof(int),
            Value = 2
        },
        new ConstantExpression {
            Type = typeof(int),
            Value = 3
        }
    }
}
---- FactoryMethods.MultilineIfFalse
new ConditionalExpression {
    Type = typeof(void),
    Test = new ConstantExpression {
        Type = typeof(bool),
        Value = true
    },
    IfTrue = new MethodCallExpression {
        Type = typeof(void),
        Arguments = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(bool),
                Value = true
            }
        },
        Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
    },
    IfFalse = new BlockExpression {
        Type = typeof(void),
        Expressions = new ReadOnlyCollection<Expression> {
            new MethodCallExpression {
                Type = typeof(void),
                Arguments = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(bool),
                        Value = false
                    }
                },
                Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
            },
            new MethodCallExpression {
                Type = typeof(void),
                Arguments = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(bool),
                        Value = false
                    }
                },
                Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
            }
        },
        Result = new MethodCallExpression {
            Type = typeof(void),
            Arguments = new ReadOnlyCollection<Expression> {
                new ConstantExpression {
                    Type = typeof(bool),
                    Value = false
                }
            },
            Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
        }
    }
}
---- FactoryMethods.MultilineIfTrue
new ConditionalExpression {
    Type = typeof(void),
    Test = new ConstantExpression {
        Type = typeof(bool),
        Value = true
    },
    IfTrue = new BlockExpression {
        Type = typeof(void),
        Expressions = new ReadOnlyCollection<Expression> {
            new MethodCallExpression {
                Type = typeof(void),
                Arguments = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(bool),
                        Value = true
                    }
                },
                Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
            },
            new MethodCallExpression {
                Type = typeof(void),
                Arguments = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(bool),
                        Value = true
                    }
                },
                Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
            }
        },
        Result = new MethodCallExpression {
            Type = typeof(void),
            Arguments = new ReadOnlyCollection<Expression> {
                new ConstantExpression {
                    Type = typeof(bool),
                    Value = true
                }
            },
            Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
        }
    },
    IfFalse = new DefaultExpression {
        Type = typeof(void)
    }
}
---- FactoryMethods.MultilineLambda
new Expression<Action> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Action),
    Body = new ConditionalExpression {
        Type = typeof(void),
        Test = new ConstantExpression {
            Type = typeof(bool),
            Value = true
        },
        IfTrue = new MethodCallExpression {
            Type = typeof(void),
            Arguments = new ReadOnlyCollection<Expression> {
                new ConstantExpression {
                    Type = typeof(bool),
                    Value = true
                }
            },
            Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
        },
        IfFalse = new DefaultExpression {
            Type = typeof(void)
        }
    },
    ReturnType = typeof(void)
}
---- FactoryMethods.MultilineTestPart
new ConditionalExpression {
    Type = typeof(int),
    Test = new BlockExpression {
        Type = typeof(bool),
        Expressions = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(bool),
                Value = true
            },
            new ConstantExpression {
                Type = typeof(bool),
                Value = true
            }
        },
        Result = new ConstantExpression {
            Type = typeof(bool),
            Value = true
        }
    },
    IfTrue = new MemberExpression {
        Type = typeof(int),
        Expression = new ConstantExpression {
            Type = typeof(string),
            Value = "true"
        },
        Member = typeof(string).GetProperty("Length")
    },
    IfFalse = new MemberExpression {
        Type = typeof(int),
        Expression = new ConstantExpression {
            Type = typeof(string),
            Value = "false"
        },
        Member = typeof(string).GetProperty("Length")
    }
}
---- FactoryMethods.MultilineTestPart1
new ConditionalExpression {
    Type = typeof(void),
    Test = new BlockExpression {
        Type = typeof(bool),
        Expressions = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(bool),
                Value = true
            },
            new ConstantExpression {
                Type = typeof(bool),
                Value = true
            }
        },
        Result = new ConstantExpression {
            Type = typeof(bool),
            Value = true
        }
    },
    IfTrue = new MethodCallExpression {
        Type = typeof(void),
        Arguments = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(bool),
                Value = true
            }
        },
        Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
    },
    IfFalse = new DefaultExpression {
        Type = typeof(void)
    }
}
---- FactoryMethods.MultiValueSwitchCase
new SwitchCase {
    TestValues = new ReadOnlyCollection<Expression> {
        new ConstantExpression {
            Type = typeof(int),
            Value = 5
        },
        new ConstantExpression {
            Type = typeof(int),
            Value = 6
        }
    },
    Body = new BlockExpression {
        Type = typeof(void),
        Expressions = new ReadOnlyCollection<Expression> {
            new MethodCallExpression {
                Type = typeof(void),
                Arguments = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(bool),
                        Value = true
                    }
                },
                Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
            },
            new MethodCallExpression {
                Type = typeof(void),
                Arguments = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(bool),
                        Value = true
                    }
                },
                Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
            }
        },
        Result = new MethodCallExpression {
            Type = typeof(void),
            Arguments = new ReadOnlyCollection<Expression> {
                new ConstantExpression {
                    Type = typeof(bool),
                    Value = true
                }
            },
            Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
        }
    }
}
---- FactoryMethods.MultiValueSwitchCase1
new SwitchCase {
    TestValues = new ReadOnlyCollection<Expression> {
        new ConstantExpression {
            Type = typeof(int),
            Value = 5
        },
        new ConstantExpression {
            Type = typeof(int),
            Value = 6
        }
    },
    Body = new MethodCallExpression {
        Type = typeof(void),
        Arguments = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(bool),
                Value = true
            }
        },
        Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
    }
}
---- FactoryMethods.NamedLambda
var s1 = new ParameterExpression {
    Type = typeof(string),
    IsByRef = false,
    Name = "s1"
};
var s2 = new ParameterExpression {
    Type = typeof(string),
    IsByRef = false,
    Name = "s2"
};

new Expression<Func<string, string, string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string, string, string>),
    Parameters = new ReadOnlyCollection<ParameterExpression> {
        s1,
        s2
    },
    Body = new BinaryExpression {
        NodeType = ExpressionType.Add,
        Type = typeof(string),
        Left = s1,
        Right = s2,
        Method = typeof(string).GetMethod("Concat", 0, new[] { typeof(string), typeof(string) })
    },
    Name = "name",
    ReturnType = typeof(string)
}
---- FactoryMethods.NamedType
new NewExpression {
    Type = typeof(Random),
    Constructor = typeof(Random).GetConstructor(new Type[] { })
}
---- FactoryMethods.NamedTypeConstructorParameters
new NewExpression {
    Type = typeof(Foo),
    Arguments = new ReadOnlyCollection<Expression> {
        new ConstantExpression {
            Type = typeof(string),
            Value = "ijkl"
        }
    },
    Constructor = typeof(Foo).GetConstructor(new[] { typeof(string) })
}
---- FactoryMethods.NamedTypeConstructorParametersWithInitializers
new MemberInitExpression {
    Type = typeof(Foo),
    NewExpression = new NewExpression {
        Type = typeof(Foo),
        Arguments = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(string),
                Value = "ijkl"
            }
        },
        Constructor = typeof(Foo).GetConstructor(new[] { typeof(string) })
    },
    Bindings = new ReadOnlyCollection<MemberBinding> {
        new MemberAssignment {
            BindingType = MemberBindingType.Assignment,
            Expression = new ConstantExpression {
                Type = typeof(string),
                Value = "abcd"
            },
            Member = typeof(Foo).GetProperty("Bar")
        },
        new MemberAssignment {
            BindingType = MemberBindingType.Assignment,
            Expression = new ConstantExpression {
                Type = typeof(string),
                Value = "efgh"
            },
            Member = typeof(Foo).GetProperty("Baz")
        }
    }
}
---- FactoryMethods.NamedTypeWithInitializer
new MemberInitExpression {
    Type = typeof(Foo),
    NewExpression = new NewExpression {
        Type = typeof(Foo),
        Constructor = typeof(Foo).GetConstructor(new Type[] { })
    },
    Bindings = new ReadOnlyCollection<MemberBinding> {
        new MemberAssignment {
            BindingType = MemberBindingType.Assignment,
            Expression = new ConstantExpression {
                Type = typeof(string),
                Value = "abcd"
            },
            Member = typeof(Foo).GetProperty("Bar")
        }
    }
}
---- FactoryMethods.NamedTypeWithInitializers
new MemberInitExpression {
    Type = typeof(Foo),
    NewExpression = new NewExpression {
        Type = typeof(Foo),
        Constructor = typeof(Foo).GetConstructor(new Type[] { })
    },
    Bindings = new ReadOnlyCollection<MemberBinding> {
        new MemberAssignment {
            BindingType = MemberBindingType.Assignment,
            Expression = new ConstantExpression {
                Type = typeof(string),
                Value = "abcd"
            },
            Member = typeof(Foo).GetProperty("Bar")
        },
        new MemberAssignment {
            BindingType = MemberBindingType.Assignment,
            Expression = new ConstantExpression {
                Type = typeof(string),
                Value = "efgh"
            },
            Member = typeof(Foo).GetProperty("Baz")
        }
    }
}
---- FactoryMethods.NestedBlockInBlockSyntax
new ConditionalExpression {
    Type = typeof(void),
    Test = new ConstantExpression {
        Type = typeof(bool),
        Value = true
    },
    IfTrue = new BlockExpression {
        Type = typeof(bool),
        Expressions = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(bool),
                Value = true
            },
            new BlockExpression {
                Type = typeof(bool),
                Expressions = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(bool),
                        Value = true
                    },
                    new ConstantExpression {
                        Type = typeof(bool),
                        Value = true
                    }
                },
                Result = new ConstantExpression {
                    Type = typeof(bool),
                    Value = true
                }
            },
            new ConstantExpression {
                Type = typeof(bool),
                Value = true
            }
        },
        Result = new ConstantExpression {
            Type = typeof(bool),
            Value = true
        }
    },
    IfFalse = new DefaultExpression {
        Type = typeof(void)
    }
}
---- FactoryMethods.NestedBlockInBlockSyntaxWithVariable
var s1 = new ParameterExpression {
    Type = typeof(string),
    IsByRef = false,
    Name = "s1"
};

new ConditionalExpression {
    Type = typeof(void),
    Test = new ConstantExpression {
        Type = typeof(bool),
        Value = true
    },
    IfTrue = new BlockExpression {
        Type = typeof(bool),
        Expressions = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(bool),
                Value = true
            },
            new BlockExpression {
                Type = typeof(bool),
                Variables = new ReadOnlyCollection<ParameterExpression> {
                    s1
                },
                Expressions = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(bool),
                        Value = true
                    },
                    new ConstantExpression {
                        Type = typeof(bool),
                        Value = true
                    }
                },
                Result = new ConstantExpression {
                    Type = typeof(bool),
                    Value = true
                }
            },
            new ConstantExpression {
                Type = typeof(bool),
                Value = true
            }
        },
        Result = new ConstantExpression {
            Type = typeof(bool),
            Value = true
        }
    },
    IfFalse = new DefaultExpression {
        Type = typeof(void)
    }
}
---- FactoryMethods.NestedBlockInTest
new ConditionalExpression {
    Type = typeof(void),
    Test = new BlockExpression {
        Type = typeof(bool),
        Expressions = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(bool),
                Value = true
            },
            new BlockExpression {
                Type = typeof(bool),
                Expressions = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(bool),
                        Value = true
                    },
                    new ConstantExpression {
                        Type = typeof(bool),
                        Value = true
                    }
                },
                Result = new ConstantExpression {
                    Type = typeof(bool),
                    Value = true
                }
            },
            new ConstantExpression {
                Type = typeof(bool),
                Value = true
            }
        },
        Result = new ConstantExpression {
            Type = typeof(bool),
            Value = true
        }
    },
    IfTrue = new ConstantExpression {
        Type = typeof(bool),
        Value = true
    },
    IfFalse = new DefaultExpression {
        Type = typeof(void)
    }
}
---- FactoryMethods.NestedBlockInTestWithVariables
var s1 = new ParameterExpression {
    Type = typeof(string),
    IsByRef = false,
    Name = "s1"
};

new ConditionalExpression {
    Type = typeof(void),
    Test = new BlockExpression {
        Type = typeof(bool),
        Expressions = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(bool),
                Value = true
            },
            new BlockExpression {
                Type = typeof(bool),
                Variables = new ReadOnlyCollection<ParameterExpression> {
                    s1
                },
                Expressions = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(bool),
                        Value = true
                    },
                    new ConstantExpression {
                        Type = typeof(bool),
                        Value = true
                    }
                },
                Result = new ConstantExpression {
                    Type = typeof(bool),
                    Value = true
                }
            },
            new ConstantExpression {
                Type = typeof(bool),
                Value = true
            }
        },
        Result = new ConstantExpression {
            Type = typeof(bool),
            Value = true
        }
    },
    IfTrue = new ConstantExpression {
        Type = typeof(bool),
        Value = true
    },
    IfFalse = new DefaultExpression {
        Type = typeof(void)
    }
}
---- FactoryMethods.NestedElse
new ConditionalExpression {
    Type = typeof(void),
    Test = new ConstantExpression {
        Type = typeof(bool),
        Value = true
    },
    IfTrue = new MethodCallExpression {
        Type = typeof(void),
        Arguments = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(bool),
                Value = true
            }
        },
        Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
    },
    IfFalse = new ConditionalExpression {
        Type = typeof(void),
        Test = new ConstantExpression {
            Type = typeof(bool),
            Value = true
        },
        IfTrue = new MethodCallExpression {
            Type = typeof(void),
            Arguments = new ReadOnlyCollection<Expression> {
                new ConstantExpression {
                    Type = typeof(bool),
                    Value = true
                }
            },
            Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
        },
        IfFalse = new DefaultExpression {
            Type = typeof(void)
        }
    }
}
---- FactoryMethods.NestedIfThen
new ConditionalExpression {
    Type = typeof(void),
    Test = new ConstantExpression {
        Type = typeof(bool),
        Value = true
    },
    IfTrue = new ConditionalExpression {
        Type = typeof(void),
        Test = new ConstantExpression {
            Type = typeof(bool),
            Value = true
        },
        IfTrue = new MethodCallExpression {
            Type = typeof(void),
            Arguments = new ReadOnlyCollection<Expression> {
                new ConstantExpression {
                    Type = typeof(bool),
                    Value = true
                }
            },
            Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
        },
        IfFalse = new DefaultExpression {
            Type = typeof(void)
        }
    },
    IfFalse = new DefaultExpression {
        Type = typeof(void)
    }
}
---- FactoryMethods.NestedInlineBlock
new BlockExpression {
    Type = typeof(bool),
    Expressions = new ReadOnlyCollection<Expression> {
        new ConstantExpression {
            Type = typeof(bool),
            Value = true
        },
        new BlockExpression {
            Type = typeof(bool),
            Expressions = new ReadOnlyCollection<Expression> {
                new ConstantExpression {
                    Type = typeof(bool),
                    Value = true
                },
                new ConstantExpression {
                    Type = typeof(bool),
                    Value = true
                }
            },
            Result = new ConstantExpression {
                Type = typeof(bool),
                Value = true
            }
        },
        new ConstantExpression {
            Type = typeof(bool),
            Value = true
        }
    },
    Result = new ConstantExpression {
        Type = typeof(bool),
        Value = true
    }
}
---- FactoryMethods.NestedInlineBlockWithVariable
var s1 = new ParameterExpression {
    Type = typeof(string),
    IsByRef = false,
    Name = "s1"
};

new BlockExpression {
    Type = typeof(bool),
    Expressions = new ReadOnlyCollection<Expression> {
        new ConstantExpression {
            Type = typeof(bool),
            Value = true
        },
        new BlockExpression {
            Type = typeof(bool),
            Variables = new ReadOnlyCollection<ParameterExpression> {
                s1
            },
            Expressions = new ReadOnlyCollection<Expression> {
                new ConstantExpression {
                    Type = typeof(bool),
                    Value = true
                },
                new ConstantExpression {
                    Type = typeof(bool),
                    Value = true
                }
            },
            Result = new ConstantExpression {
                Type = typeof(bool),
                Value = true
            }
        },
        new ConstantExpression {
            Type = typeof(bool),
            Value = true
        }
    },
    Result = new ConstantExpression {
        Type = typeof(bool),
        Value = true
    }
}
---- FactoryMethods.NestedLambda
var s1 = new ParameterExpression {
    Type = typeof(string),
    IsByRef = false,
    Name = "s1"
};
var s2 = new ParameterExpression {
    Type = typeof(string),
    IsByRef = false,
    Name = "s2"
};

new Expression<Func<Func<string, string, string>>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<Func<string, string, string>>),
    Body = new Expression<Func<string, string, string>> {
        NodeType = ExpressionType.Lambda,
        Type = typeof(Func<string, string, string>),
        Parameters = new ReadOnlyCollection<ParameterExpression> {
            s1,
            s2
        },
        Body = new BinaryExpression {
            NodeType = ExpressionType.Add,
            Type = typeof(string),
            Left = s1,
            Right = s2,
            Method = typeof(string).GetMethod("Concat", 0, new[] { typeof(string), typeof(string) })
        },
        ReturnType = typeof(string)
    },
    ReturnType = typeof(Func<string, string, string>)
}
---- FactoryMethods.NonVoidConditionalWithElse
new ConditionalExpression {
    Type = typeof(int),
    Test = new ConstantExpression {
        Type = typeof(bool),
        Value = true
    },
    IfTrue = new MemberExpression {
        Type = typeof(int),
        Expression = new ConstantExpression {
            Type = typeof(string),
            Value = "true"
        },
        Member = typeof(string).GetProperty("Length")
    },
    IfFalse = new MemberExpression {
        Type = typeof(int),
        Expression = new ConstantExpression {
            Type = typeof(string),
            Value = "false"
        },
        Member = typeof(string).GetProperty("Length")
    }
}
---- FactoryMethods.NonVoidConditionalWithoutElse
new ConditionalExpression {
    Type = typeof(int),
    Test = new ConstantExpression {
        Type = typeof(bool),
        Value = true
    },
    IfTrue = new MemberExpression {
        Type = typeof(int),
        Expression = new ConstantExpression {
            Type = typeof(string),
            Value = "true"
        },
        Member = typeof(string).GetProperty("Length")
    },
    IfFalse = new DefaultExpression {
        Type = typeof(int)
    }
}
---- FactoryMethods.NoParametersNonVoidReturn
new Expression<Func<string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string>),
    Body = new ConstantExpression {
        Type = typeof(string),
        Value = "abcd"
    },
    ReturnType = typeof(string)
}
---- FactoryMethods.NoParametersVoidReturn
new Expression<Action> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Action),
    Body = new MethodCallExpression {
        Type = typeof(void),
        Method = typeof(Console).GetMethod("WriteLine", new Type[] { })
    },
    ReturnType = typeof(void)
}
---- FactoryMethods.OldTuple
new ConstantExpression {
    Type = typeof(Tuple<string, int>),
    Value = Tuple.Create("abcd", 5)
}
---- FactoryMethods.OneParameterNonVoidReturn
var s = new ParameterExpression {
    Type = typeof(string),
    IsByRef = false,
    Name = "s"
};

new Expression<Func<string, string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string, string>),
    Parameters = new ReadOnlyCollection<ParameterExpression> {
        s
    },
    Body = s,
    ReturnType = typeof(string)
}
---- FactoryMethods.OneParameterVoidReturn
var s = new ParameterExpression {
    Type = typeof(string),
    IsByRef = false,
    Name = "s"
};

new Expression<Action<string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Action<string>),
    Parameters = new ReadOnlyCollection<ParameterExpression> {
        s
    },
    Body = new MethodCallExpression {
        Type = typeof(void),
        Arguments = new ReadOnlyCollection<Expression> {
            s
        },
        Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(string) })
    },
    ReturnType = typeof(void)
}
---- FactoryMethods.PropertyIndexer
new IndexExpression {
    Type = typeof(string),
    Object = lstString,
    Arguments = new ReadOnlyCollection<Expression> {
        new ConstantExpression {
            Type = typeof(int),
            Value = 0
        }
    },
    Indexer = typeof(List<string>).GetProperty("Item")
}
---- FactoryMethods.Random
new ConstantExpression {
    Type = typeof(Random),
    Value = #Random
}
---- FactoryMethods.RuntimeVariablesWithinBlock
var s2 = new ParameterExpression {
    Type = typeof(string),
    IsByRef = false,
    Name = "s2"
};

new BlockExpression {
    Type = typeof(IRuntimeVariables),
    Variables = new ReadOnlyCollection<ParameterExpression> {
        s2
    },
    Expressions = new ReadOnlyCollection<Expression> {
        new ConstantExpression {
            Type = typeof(bool),
            Value = true
        },
        new RuntimeVariablesExpression {
            Type = typeof(IRuntimeVariables),
            Variables = new ReadOnlyCollection<ParameterExpression> {
                x,
                s1
            }
        }
    },
    Result = new RuntimeVariablesExpression {
        Type = typeof(IRuntimeVariables),
        Variables = new ReadOnlyCollection<ParameterExpression> {
            x,
            s1
        }
    }
}
---- FactoryMethods.SingleDimensionInit
new NewArrayExpression {
    NodeType = ExpressionType.NewArrayInit,
    Type = typeof(string[]),
    Expressions = new ReadOnlyCollection<Expression> {
        new ConstantExpression {
            Type = typeof(string)
        }
    }
}
---- FactoryMethods.SingleDimensionInitExplicitType
new NewArrayExpression {
    NodeType = ExpressionType.NewArrayInit,
    Type = typeof(object[]),
    Expressions = new ReadOnlyCollection<Expression> {
        new ConstantExpression {
            Type = typeof(string)
        }
    }
}
---- FactoryMethods.SingleDimensionWithBounds
new NewArrayExpression {
    NodeType = ExpressionType.NewArrayBounds,
    Type = typeof(string[]),
    Expressions = new ReadOnlyCollection<Expression> {
        new ConstantExpression {
            Type = typeof(int),
            Value = 5
        }
    }
}
---- FactoryMethods.SingleValueSwitchCase
new SwitchCase {
    TestValues = new ReadOnlyCollection<Expression> {
        new ConstantExpression {
            Type = typeof(int),
            Value = 5
        }
    },
    Body = new BlockExpression {
        Type = typeof(void),
        Expressions = new ReadOnlyCollection<Expression> {
            new MethodCallExpression {
                Type = typeof(void),
                Arguments = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(bool),
                        Value = true
                    }
                },
                Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
            },
            new MethodCallExpression {
                Type = typeof(void),
                Arguments = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(bool),
                        Value = true
                    }
                },
                Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
            }
        },
        Result = new MethodCallExpression {
            Type = typeof(void),
            Arguments = new ReadOnlyCollection<Expression> {
                new ConstantExpression {
                    Type = typeof(bool),
                    Value = true
                }
            },
            Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
        }
    }
}
---- FactoryMethods.SingleValueSwitchCase1
new SwitchCase {
    TestValues = new ReadOnlyCollection<Expression> {
        new ConstantExpression {
            Type = typeof(int),
            Value = 5
        }
    },
    Body = new MethodCallExpression {
        Type = typeof(void),
        Arguments = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(bool),
                Value = true
            }
        },
        Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
    }
}
---- FactoryMethods.StaticMember
new MemberExpression {
    Type = typeof(string),
    Member = typeof(string).GetField("Empty")
}
---- FactoryMethods.StaticMethod0Arguments
new MethodCallExpression {
    Type = typeof(void),
    Method = typeof(Dummy).GetMethod("DummyMethod")
}
---- FactoryMethods.StaticMethod1Argument
new MethodCallExpression {
    Type = typeof(string),
    Arguments = new ReadOnlyCollection<Expression> {
        new ConstantExpression {
            Type = typeof(string)
        }
    },
    Method = typeof(string).GetMethod("Intern")
}
---- FactoryMethods.StaticMethod2Arguments
new MethodCallExpression {
    Type = typeof(string),
    Arguments = new ReadOnlyCollection<Expression> {
        new ConstantExpression {
            Type = typeof(string),
            Value = ","
        },
        new NewArrayExpression {
            NodeType = ExpressionType.NewArrayInit,
            Type = typeof(string[]),
            Expressions = new ReadOnlyCollection<Expression> {
                new ConstantExpression {
                    Type = typeof(string),
                    Value = "a"
                },
                new ConstantExpression {
                    Type = typeof(string),
                    Value = "b"
                }
            }
        }
    },
    Method = typeof(string).GetMethod("Join", 0, new[] { typeof(string), typeof(string[]) })
}
---- FactoryMethods.StringConcat
new MethodCallExpression {
    Type = typeof(string),
    Arguments = new ReadOnlyCollection<Expression> {
        s1,
        s2
    },
    Method = typeof(string).GetMethod("Concat", 0, new[] { typeof(string), typeof(string) })
}
---- FactoryMethods.SwitchOnExpressionWithDefaultMultiStatement
new SwitchExpression {
    Type = typeof(void),
    SwitchValue = i,
    Cases = new ReadOnlyCollection<SwitchCase> {
        new SwitchCase {
            TestValues = new ReadOnlyCollection<Expression> {
                new ConstantExpression {
                    Type = typeof(int),
                    Value = 4
                }
            },
            Body = new MethodCallExpression {
                Type = typeof(void),
                Arguments = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(bool),
                        Value = true
                    }
                },
                Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
            }
        },
        new SwitchCase {
            TestValues = new ReadOnlyCollection<Expression> {
                new ConstantExpression {
                    Type = typeof(int),
                    Value = 5
                }
            },
            Body = new MethodCallExpression {
                Type = typeof(void),
                Arguments = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(bool),
                        Value = false
                    }
                },
                Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
            }
        }
    },
    DefaultBody = new BlockExpression {
        Type = typeof(void),
        Expressions = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(bool),
                Value = true
            },
            new ConstantExpression {
                Type = typeof(bool),
                Value = true
            }
        },
        Result = new ConstantExpression {
            Type = typeof(bool),
            Value = true
        }
    }
}
---- FactoryMethods.SwitchOnExpressionWithDefaultSingleStatement
new SwitchExpression {
    Type = typeof(void),
    SwitchValue = i,
    Cases = new ReadOnlyCollection<SwitchCase> {
        new SwitchCase {
            TestValues = new ReadOnlyCollection<Expression> {
                new ConstantExpression {
                    Type = typeof(int),
                    Value = 4
                }
            },
            Body = new MethodCallExpression {
                Type = typeof(void),
                Arguments = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(bool),
                        Value = true
                    }
                },
                Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
            }
        },
        new SwitchCase {
            TestValues = new ReadOnlyCollection<Expression> {
                new ConstantExpression {
                    Type = typeof(int),
                    Value = 5
                }
            },
            Body = new MethodCallExpression {
                Type = typeof(void),
                Arguments = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(bool),
                        Value = false
                    }
                },
                Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
            }
        }
    },
    DefaultBody = new DefaultExpression {
        Type = typeof(void)
    }
}
---- FactoryMethods.SwitchOnExpressionWithoutDefault
new SwitchExpression {
    Type = typeof(void),
    SwitchValue = i,
    Cases = new ReadOnlyCollection<SwitchCase> {
        new SwitchCase {
            TestValues = new ReadOnlyCollection<Expression> {
                new ConstantExpression {
                    Type = typeof(int),
                    Value = 4
                }
            },
            Body = new MethodCallExpression {
                Type = typeof(void),
                Arguments = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(bool),
                        Value = true
                    }
                },
                Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
            }
        },
        new SwitchCase {
            TestValues = new ReadOnlyCollection<Expression> {
                new ConstantExpression {
                    Type = typeof(int),
                    Value = 5
                }
            },
            Body = new MethodCallExpression {
                Type = typeof(void),
                Arguments = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(bool),
                        Value = false
                    }
                },
                Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
            }
        }
    }
}
---- FactoryMethods.SwitchOnMultipleStatementsWithDefault
new SwitchExpression {
    Type = typeof(void),
    SwitchValue = new BlockExpression {
        Type = typeof(int),
        Expressions = new ReadOnlyCollection<Expression> {
            i,
            j
        },
        Result = j
    },
    Cases = new ReadOnlyCollection<SwitchCase> {
        new SwitchCase {
            TestValues = new ReadOnlyCollection<Expression> {
                new ConstantExpression {
                    Type = typeof(int),
                    Value = 4
                }
            },
            Body = new MethodCallExpression {
                Type = typeof(void),
                Arguments = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(bool),
                        Value = true
                    }
                },
                Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
            }
        },
        new SwitchCase {
            TestValues = new ReadOnlyCollection<Expression> {
                new ConstantExpression {
                    Type = typeof(int),
                    Value = 5
                }
            },
            Body = new MethodCallExpression {
                Type = typeof(void),
                Arguments = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(bool),
                        Value = false
                    }
                },
                Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
            }
        }
    },
    DefaultBody = new BlockExpression {
        Type = typeof(void),
        Expressions = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(bool),
                Value = true
            },
            new ConstantExpression {
                Type = typeof(bool),
                Value = true
            }
        },
        Result = new ConstantExpression {
            Type = typeof(bool),
            Value = true
        }
    }
}
---- FactoryMethods.SwitchOnMultipleStatementsWithoutDefault
new SwitchExpression {
    Type = typeof(void),
    SwitchValue = new BlockExpression {
        Type = typeof(int),
        Expressions = new ReadOnlyCollection<Expression> {
            i,
            j
        },
        Result = j
    },
    Cases = new ReadOnlyCollection<SwitchCase> {
        new SwitchCase {
            TestValues = new ReadOnlyCollection<Expression> {
                new ConstantExpression {
                    Type = typeof(int),
                    Value = 4
                }
            },
            Body = new MethodCallExpression {
                Type = typeof(void),
                Arguments = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(bool),
                        Value = true
                    }
                },
                Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
            }
        },
        new SwitchCase {
            TestValues = new ReadOnlyCollection<Expression> {
                new ConstantExpression {
                    Type = typeof(int),
                    Value = 5
                }
            },
            Body = new MethodCallExpression {
                Type = typeof(void),
                Arguments = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(bool),
                        Value = false
                    }
                },
                Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
            }
        }
    }
}
---- FactoryMethods.TwoParametersNonVoidReturn
var s1 = new ParameterExpression {
    Type = typeof(string),
    IsByRef = false,
    Name = "s1"
};
var s2 = new ParameterExpression {
    Type = typeof(string),
    IsByRef = false,
    Name = "s2"
};

new Expression<Func<string, string, string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string, string, string>),
    Parameters = new ReadOnlyCollection<ParameterExpression> {
        s1,
        s2
    },
    Body = new BinaryExpression {
        NodeType = ExpressionType.Add,
        Type = typeof(string),
        Left = s1,
        Right = s2,
        Method = typeof(string).GetMethod("Concat", 0, new[] { typeof(string), typeof(string) })
    },
    ReturnType = typeof(string)
}
---- FactoryMethods.TwoParametersVoidReturn
var s1 = new ParameterExpression {
    Type = typeof(string),
    IsByRef = false,
    Name = "s1"
};
var s2 = new ParameterExpression {
    Type = typeof(string),
    IsByRef = false,
    Name = "s2"
};

new Expression<Action<string, string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Action<string, string>),
    Parameters = new ReadOnlyCollection<ParameterExpression> {
        s1,
        s2
    },
    Body = new MethodCallExpression {
        Type = typeof(void),
        Arguments = new ReadOnlyCollection<Expression> {
            new BinaryExpression {
                NodeType = ExpressionType.Add,
                Type = typeof(string),
                Left = s1,
                Right = s2,
                Method = typeof(string).GetMethod("Concat", 0, new[] { typeof(string), typeof(string) })
            }
        },
        Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(string) })
    },
    ReturnType = typeof(void)
}
---- FactoryMethods.Type
new ConstantExpression {
    Type = typeof(RuntimeType),
    Value = typeof(string)
}
---- FactoryMethods.ValueTuple
new ConstantExpression {
    Type = typeof(ValueTuple<string, int>),
    Value = ("abcd", 5)
}
---- FactoryMethods.VoidConditional1WithElse
new ConditionalExpression {
    Type = typeof(void),
    Test = new ConstantExpression {
        Type = typeof(bool),
        Value = true
    },
    IfTrue = new MethodCallExpression {
        Type = typeof(void),
        Arguments = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(bool),
                Value = true
            }
        },
        Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
    },
    IfFalse = new MethodCallExpression {
        Type = typeof(void),
        Arguments = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(bool),
                Value = false
            }
        },
        Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
    }
}
---- FactoryMethods.VoidConditional1WithoutElse
new ConditionalExpression {
    Type = typeof(void),
    Test = new ConstantExpression {
        Type = typeof(bool),
        Value = true
    },
    IfTrue = new MethodCallExpression {
        Type = typeof(void),
        Arguments = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(bool),
                Value = true
            }
        },
        Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
    },
    IfFalse = new DefaultExpression {
        Type = typeof(void)
    }
}
---- FactoryMethods.VoidConditionalWithElse
new ConditionalExpression {
    Type = typeof(void),
    Test = new ConstantExpression {
        Type = typeof(bool),
        Value = true
    },
    IfTrue = new MethodCallExpression {
        Type = typeof(void),
        Arguments = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(bool),
                Value = true
            }
        },
        Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
    },
    IfFalse = new MethodCallExpression {
        Type = typeof(void),
        Arguments = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(bool),
                Value = false
            }
        },
        Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
    }
}
---- FactoryMethods.VoidConditionalWithoutElse
new ConditionalExpression {
    Type = typeof(void),
    Test = new ConstantExpression {
        Type = typeof(bool),
        Value = true
    },
    IfTrue = new MethodCallExpression {
        Type = typeof(void),
        Arguments = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(bool),
                Value = true
            }
        },
        Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(bool) })
    },
    IfFalse = new DefaultExpression {
        Type = typeof(void)
    }
}
---- VBCompiler.Add
new Expression<Func<double>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<double>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.Add,
        Type = typeof(double),
        Left = new MemberExpression {
            Type = typeof(double),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_x")
        },
        Right = new MemberExpression {
            Type = typeof(double),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_y")
        }
    },
    ReturnType = typeof(double)
}
---- VBCompiler.AndAlso
new Expression<Func<bool>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<bool>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.AndAlso,
        Type = typeof(bool),
        Left = new MemberExpression {
            Type = typeof(bool),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_b1")
        },
        Right = new MemberExpression {
            Type = typeof(bool),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_b2")
        }
    },
    ReturnType = typeof(bool)
}
---- VBCompiler.AndBitwise
new Expression<Func<int>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<int>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.And,
        Type = typeof(int),
        Left = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_i")
        },
        Right = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_j")
        }
    },
    ReturnType = typeof(int)
}
---- VBCompiler.AndLogical
new Expression<Func<bool>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<bool>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.And,
        Type = typeof(bool),
        Left = new MemberExpression {
            Type = typeof(bool),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_b1")
        },
        Right = new MemberExpression {
            Type = typeof(bool),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_b2")
        }
    },
    ReturnType = typeof(bool)
}
---- VBCompiler.AnonymousType
new Expression<Func<{ string Bar, string Baz }>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<{ string Bar, string Baz }>),
    Body = new NewExpression {
        Type = typeof(<anonymous({ string Bar, string Baz })>),
        Arguments = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(string),
                Value = "abcd"
            },
            new ConstantExpression {
                Type = typeof(string),
                Value = "efgh"
            }
        },
        Constructor = typeof(<anonymous({ string Bar, string Baz })>).GetConstructor(new[] { typeof(string), typeof(string) }),
        Members = #TrueReadOnlyCollection<MemberInfo>
    },
    ReturnType = typeof(<anonymous({ string Bar, string Baz })>)
}
---- VBCompiler.AnonymousTypeFromVariables
new Expression<Func<{ string Bar, string Baz }>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<{ string Bar, string Baz }>),
    Body = new NewExpression {
        Type = typeof(<anonymous({ string Bar, string Baz })>),
        Arguments = new ReadOnlyCollection<Expression> {
            new MemberExpression {
                Type = typeof(string),
                Expression = new ConstantExpression {
                    Type = typeof(<closure>),
                    Value = #<closure>
                },
                Member = typeof(<closure>).GetField("$VB$Local_Bar")
            },
            new MemberExpression {
                Type = typeof(string),
                Expression = new ConstantExpression {
                    Type = typeof(<closure>),
                    Value = #<closure>
                },
                Member = typeof(<closure>).GetField("$VB$Local_Baz")
            }
        },
        Constructor = typeof(<anonymous({ string Bar, string Baz })>).GetConstructor(new[] { typeof(string), typeof(string) }),
        Members = #TrueReadOnlyCollection<MemberInfo>
    },
    ReturnType = typeof(<anonymous({ string Bar, string Baz })>)
}
---- VBCompiler.ArrayIndex
new Expression<Func<string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.ArrayIndex,
        Type = typeof(string),
        Left = new MemberExpression {
            Type = typeof(string[]),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_arr")
        },
        Right = new ConstantExpression {
            Type = typeof(int),
            Value = 0
        }
    },
    ReturnType = typeof(string)
}
---- VBCompiler.ArrayLength
new Expression<Func<int>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<int>),
    Body = new UnaryExpression {
        NodeType = ExpressionType.ArrayLength,
        Type = typeof(int),
        Operand = new MemberExpression {
            Type = typeof(string[]),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_arr")
        }
    },
    ReturnType = typeof(int)
}
---- VBCompiler.ArrayMultipleIndex
new Expression<Func<string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string>),
    Body = new MethodCallExpression {
        Type = typeof(string),
        Object = new MemberExpression {
            Type = typeof(string[,]),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_arr")
        },
        Arguments = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(int),
                Value = 5
            },
            new ConstantExpression {
                Type = typeof(int),
                Value = 6
            }
        },
        Method = typeof(string[,]).GetMethod("Get")
    },
    ReturnType = typeof(string)
}
---- VBCompiler.ArrayOfMultidimensionalArray
new Expression<Func<string[][,]>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string[][,]>),
    Body = new NewArrayExpression {
        NodeType = ExpressionType.NewArrayBounds,
        Type = typeof(string[][,]),
        Expressions = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(int),
                Value = 5
            }
        }
    },
    ReturnType = typeof(string[][,])
}
---- VBCompiler.ArraySingleIndex
new Expression<Func<string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.ArrayIndex,
        Type = typeof(string),
        Left = new MemberExpression {
            Type = typeof(string[]),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_arr")
        },
        Right = new ConstantExpression {
            Type = typeof(int),
            Value = 5
        }
    },
    ReturnType = typeof(string)
}
---- VBCompiler.BitwiseNot
new Expression<Func<int>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<int>),
    Body = new UnaryExpression {
        NodeType = ExpressionType.Not,
        Type = typeof(int),
        Operand = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_i")
        }
    },
    ReturnType = typeof(int)
}
---- VBCompiler.ClosedVariable
new Expression<Func<string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string>),
    Body = new MemberExpression {
        Type = typeof(string),
        Expression = new ConstantExpression {
            Type = typeof(<closure>),
            Value = #<closure>
        },
        Member = typeof(<closure>).GetField("$VB$Local_s")
    },
    ReturnType = typeof(string)
}
---- VBCompiler.Coalesce
new Expression<Func<string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.Coalesce,
        Type = typeof(string),
        Left = new MemberExpression {
            Type = typeof(string),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_s1")
        },
        Right = new MemberExpression {
            Type = typeof(string),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_s2")
        }
    },
    ReturnType = typeof(string)
}
---- VBCompiler.CObject
new Expression<Func<object>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<object>),
    Body = new UnaryExpression {
        NodeType = ExpressionType.Convert,
        Type = typeof(object),
        Operand = new MemberExpression {
            Type = typeof(List<string>),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_lst")
        }
    },
    ReturnType = typeof(object)
}
---- VBCompiler.CollectionTypeWithInitializer
new Expression<Func<List<string>>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<List<string>>),
    Body = new ListInitExpression {
        Type = typeof(List<string>),
        NewExpression = new NewExpression {
            Type = typeof(List<string>),
            Constructor = typeof(List<string>).GetConstructor(new Type[] { })
        },
        Initializers = new ReadOnlyCollection<ElementInit> {
            new ElementInit {
                AddMethod = typeof(List<string>).GetMethod("Add"),
                Arguments = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(string),
                        Value = "abcd"
                    }
                }
            },
            new ElementInit {
                AddMethod = typeof(List<string>).GetMethod("Add"),
                Arguments = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(string),
                        Value = "efgh"
                    }
                }
            }
        }
    },
    ReturnType = typeof(List<string>)
}
---- VBCompiler.CollectionTypeWithMultipleElementsInitializers
new Expression<Func<Wrapper>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<Wrapper>),
    Body = new ListInitExpression {
        Type = typeof(Wrapper),
        NewExpression = new NewExpression {
            Type = typeof(Wrapper),
            Constructor = typeof(Wrapper).GetConstructor(new Type[] { })
        },
        Initializers = new ReadOnlyCollection<ElementInit> {
            new ElementInit {
                AddMethod = typeof(Wrapper).GetMethod("Add", BindingFlags.Instance | BindingFlags.NonPublic, null, new[] { typeof(string), typeof(string) }, null),
                Arguments = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(string),
                        Value = "ab"
                    },
                    new ConstantExpression {
                        Type = typeof(string),
                        Value = "cd"
                    }
                }
            },
            new ElementInit {
                AddMethod = typeof(Wrapper).GetMethod("Add", BindingFlags.Instance | BindingFlags.NonPublic, null, new[] { typeof(string), typeof(string) }, null),
                Arguments = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(string),
                        Value = "ef"
                    },
                    new ConstantExpression {
                        Type = typeof(string),
                        Value = "gh"
                    }
                }
            }
        }
    },
    ReturnType = typeof(Wrapper)
}
---- VBCompiler.CollectionTypeWithSingleOrMultipleElementsInitializers
new Expression<Func<Wrapper>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<Wrapper>),
    Body = new ListInitExpression {
        Type = typeof(Wrapper),
        NewExpression = new NewExpression {
            Type = typeof(Wrapper),
            Constructor = typeof(Wrapper).GetConstructor(new Type[] { })
        },
        Initializers = new ReadOnlyCollection<ElementInit> {
            new ElementInit {
                AddMethod = typeof(Wrapper).GetMethod("Add", BindingFlags.Instance | BindingFlags.NonPublic, null, new[] { typeof(string), typeof(string) }, null),
                Arguments = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(string),
                        Value = "ab"
                    },
                    new ConstantExpression {
                        Type = typeof(string),
                        Value = "cd"
                    }
                }
            },
            new ElementInit {
                AddMethod = typeof(Wrapper).GetMethod("Add", BindingFlags.Instance | BindingFlags.NonPublic, null, new[] { typeof(string) }, null),
                Arguments = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(string),
                        Value = "ef"
                    }
                }
            }
        }
    },
    ReturnType = typeof(Wrapper)
}
---- VBCompiler.Conditional
var i = new ParameterExpression {
    Type = typeof(int),
    IsByRef = false,
    Name = "i"
};

new Expression<Func<int, int>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<int, int>),
    Parameters = new ReadOnlyCollection<ParameterExpression> {
        i
    },
    Body = new ConditionalExpression {
        Type = typeof(int),
        Test = new BinaryExpression {
            NodeType = ExpressionType.GreaterThan,
            Type = typeof(bool),
            Left = i,
            Right = new ConstantExpression {
                Type = typeof(int),
                Value = 10
            }
        },
        IfTrue = i,
        IfFalse = new BinaryExpression {
            NodeType = ExpressionType.AddChecked,
            Type = typeof(int),
            Left = i,
            Right = new ConstantExpression {
                Type = typeof(int),
                Value = 10
            }
        }
    },
    ReturnType = typeof(int)
}
---- VBCompiler.ConstantNothingToObject
new Expression<Func<object>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<object>),
    Body = new ConstantExpression {
        Type = typeof(object)
    },
    ReturnType = typeof(object)
}
---- VBCompiler.ConstantNothingToReferenceType
new Expression<Func<string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string>),
    Body = new ConstantExpression {
        Type = typeof(string)
    },
    ReturnType = typeof(string)
}
---- VBCompiler.ConstantNothingToValueType
new Expression<Func<int>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<int>),
    Body = new ConstantExpression {
        Type = typeof(int),
        Value = 0
    },
    ReturnType = typeof(int)
}
---- VBCompiler.Convert
new Expression<Func<Random>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<Random>),
    Body = new UnaryExpression {
        NodeType = ExpressionType.Convert,
        Type = typeof(Random),
        Operand = new MemberExpression {
            Type = typeof(object),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_o")
        }
    },
    ReturnType = typeof(Random)
}
---- VBCompiler.Divide
new Expression<Func<double>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<double>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.Divide,
        Type = typeof(double),
        Left = new MemberExpression {
            Type = typeof(double),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_x")
        },
        Right = new MemberExpression {
            Type = typeof(double),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_y")
        }
    },
    ReturnType = typeof(double)
}
---- VBCompiler.Equal
new Expression<Func<bool>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<bool>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.Equal,
        Type = typeof(bool),
        Left = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_i")
        },
        Right = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_j")
        }
    },
    ReturnType = typeof(bool)
}
---- VBCompiler.EscapedString
new Expression<Func<string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string>),
    Body = new ConstantExpression {
        Type = typeof(string),
        Value = "\""
    },
    ReturnType = typeof(string)
}
---- VBCompiler.ExclusiveOrBitwise
new Expression<Func<int>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<int>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.ExclusiveOr,
        Type = typeof(int),
        Left = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_i")
        },
        Right = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_j")
        }
    },
    ReturnType = typeof(int)
}
---- VBCompiler.ExclusiveOrLogical
new Expression<Func<bool>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<bool>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.ExclusiveOr,
        Type = typeof(bool),
        Left = new MemberExpression {
            Type = typeof(bool),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_b1")
        },
        Right = new MemberExpression {
            Type = typeof(bool),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_b2")
        }
    },
    ReturnType = typeof(bool)
}
---- VBCompiler.False
new Expression<Func<bool>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<bool>),
    Body = new ConstantExpression {
        Type = typeof(bool),
        Value = false
    },
    ReturnType = typeof(bool)
}
---- VBCompiler.GreaterThan
new Expression<Func<bool>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<bool>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.GreaterThan,
        Type = typeof(bool),
        Left = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_i")
        },
        Right = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_j")
        }
    },
    ReturnType = typeof(bool)
}
---- VBCompiler.GreaterThanOrEqual
new Expression<Func<bool>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<bool>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.GreaterThanOrEqual,
        Type = typeof(bool),
        Left = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_i")
        },
        Right = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_j")
        }
    },
    ReturnType = typeof(bool)
}
---- VBCompiler.InstanceMember
new Expression<Func<int>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<int>),
    Body = new MemberExpression {
        Type = typeof(int),
        Expression = new MemberExpression {
            Type = typeof(string),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_s")
        },
        Member = typeof(string).GetProperty("Length")
    },
    ReturnType = typeof(int)
}
---- VBCompiler.InstanceMethod0Arguments
new Expression<Func<string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string>),
    Body = new MethodCallExpression {
        Type = typeof(string),
        Object = new MemberExpression {
            Type = typeof(string),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_s")
        },
        Method = typeof(string).GetMethod("ToString", new Type[] { })
    },
    ReturnType = typeof(string)
}
---- VBCompiler.InstanceMethod1Argument
new Expression<Func<int>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<int>),
    Body = new MethodCallExpression {
        Type = typeof(int),
        Object = new MemberExpression {
            Type = typeof(string),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_s")
        },
        Arguments = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(string)
            }
        },
        Method = typeof(string).GetMethod("CompareTo", new[] { typeof(string) })
    },
    ReturnType = typeof(int)
}
---- VBCompiler.InstanceMethod2Arguments
new Expression<Func<int>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<int>),
    Body = new MethodCallExpression {
        Type = typeof(int),
        Object = new MemberExpression {
            Type = typeof(string),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_s")
        },
        Arguments = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(char),
                Value = 'a'
            },
            new ConstantExpression {
                Type = typeof(int),
                Value = 2
            }
        },
        Method = typeof(string).GetMethod("IndexOf", new[] { typeof(char), typeof(int) })
    },
    ReturnType = typeof(int)
}
---- VBCompiler.Integer
new Expression<Func<int>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<int>),
    Body = new ConstantExpression {
        Type = typeof(int),
        Value = 5
    },
    ReturnType = typeof(int)
}
---- VBCompiler.InterpolatedString
new Expression<Func<string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string>),
    Body = new MethodCallExpression {
        Type = typeof(string),
        Arguments = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(string),
                Value = "{0:yyyy-MM-dd}"
            },
            new UnaryExpression {
                NodeType = ExpressionType.Convert,
                Type = typeof(object),
                Operand = new ConstantExpression {
                    Type = typeof(DateTime),
                    Value = #DateTime
                }
            }
        },
        Method = typeof(string).GetMethod("Format", new[] { typeof(string), typeof(object) })
    },
    ReturnType = typeof(string)
}
---- VBCompiler.InvocationNoArguments
new Expression<Func<int>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<int>),
    Body = new InvocationExpression {
        Type = typeof(int),
        Expression = new MemberExpression {
            Type = typeof(VB$AnonymousDelegate<int>),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_del")
        }
    },
    ReturnType = typeof(int)
}
---- VBCompiler.InvocationOneArgument
new Expression<Func<int>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<int>),
    Body = new InvocationExpression {
        Type = typeof(int),
        Arguments = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(int),
                Value = 5
            }
        },
        Expression = new MemberExpression {
            Type = typeof(VB$AnonymousDelegate<int, int>),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_del")
        }
    },
    ReturnType = typeof(int)
}
---- VBCompiler.JaggedWithBounds
new Expression<Func<string[][]>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string[][]>),
    Body = new NewArrayExpression {
        NodeType = ExpressionType.NewArrayBounds,
        Type = typeof(string[][]),
        Expressions = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(int),
                Value = 5
            }
        }
    },
    ReturnType = typeof(string[][])
}
---- VBCompiler.JaggedWithElementsExplicitType
new Expression<Func<object[][]>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<object[][]>),
    Body = new NewArrayExpression {
        NodeType = ExpressionType.NewArrayInit,
        Type = typeof(object[][]),
        Expressions = new ReadOnlyCollection<Expression> {
            new UnaryExpression {
                NodeType = ExpressionType.Convert,
                Type = typeof(object[]),
                Operand = new NewArrayExpression {
                    NodeType = ExpressionType.NewArrayInit,
                    Type = typeof(string[]),
                    Expressions = new ReadOnlyCollection<Expression> {
                        new ConstantExpression {
                            Type = typeof(string),
                            Value = "ab"
                        },
                        new ConstantExpression {
                            Type = typeof(string),
                            Value = "cd"
                        }
                    }
                }
            },
            new UnaryExpression {
                NodeType = ExpressionType.Convert,
                Type = typeof(object[]),
                Operand = new NewArrayExpression {
                    NodeType = ExpressionType.NewArrayInit,
                    Type = typeof(string[]),
                    Expressions = new ReadOnlyCollection<Expression> {
                        new ConstantExpression {
                            Type = typeof(string),
                            Value = "ef"
                        },
                        new ConstantExpression {
                            Type = typeof(string),
                            Value = "gh"
                        }
                    }
                }
            }
        }
    },
    ReturnType = typeof(object[][])
}
---- VBCompiler.JaggedWithElementsImplicitType
new Expression<Func<string[][]>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string[][]>),
    Body = new NewArrayExpression {
        NodeType = ExpressionType.NewArrayInit,
        Type = typeof(string[][]),
        Expressions = new ReadOnlyCollection<Expression> {
            new NewArrayExpression {
                NodeType = ExpressionType.NewArrayInit,
                Type = typeof(string[]),
                Expressions = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(string),
                        Value = "ab"
                    },
                    new ConstantExpression {
                        Type = typeof(string),
                        Value = "cd"
                    }
                }
            },
            new NewArrayExpression {
                NodeType = ExpressionType.NewArrayInit,
                Type = typeof(string[]),
                Expressions = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(string),
                        Value = "ef"
                    },
                    new ConstantExpression {
                        Type = typeof(string),
                        Value = "gh"
                    }
                }
            }
        }
    },
    ReturnType = typeof(string[][])
}
---- VBCompiler.JaggedWithElementsImplicitTypeInnerNonLiteral
new Expression<Func<string[][]>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string[][]>),
    Body = new NewArrayExpression {
        NodeType = ExpressionType.NewArrayInit,
        Type = typeof(string[][]),
        Expressions = new ReadOnlyCollection<Expression> {
            new MemberExpression {
                Type = typeof(string[]),
                Expression = new ConstantExpression {
                    Type = typeof(<closure>),
                    Value = #<closure>
                },
                Member = typeof(<closure>).GetField("$VB$Local_arr1")
            },
            new MemberExpression {
                Type = typeof(string[]),
                Expression = new ConstantExpression {
                    Type = typeof(<closure>),
                    Value = #<closure>
                },
                Member = typeof(<closure>).GetField("$VB$Local_arr2")
            }
        }
    },
    ReturnType = typeof(string[][])
}
---- VBCompiler.LeftShift
new Expression<Func<int>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<int>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.LeftShift,
        Type = typeof(int),
        Left = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_i")
        },
        Right = new BinaryExpression {
            NodeType = ExpressionType.And,
            Type = typeof(int),
            Left = new MemberExpression {
                Type = typeof(int),
                Expression = new ConstantExpression {
                    Type = typeof(<closure>),
                    Value = #<closure>
                },
                Member = typeof(<closure>).GetField("$VB$Local_j")
            },
            Right = new ConstantExpression {
                Type = typeof(int),
                Value = 31
            }
        }
    },
    ReturnType = typeof(int)
}
---- VBCompiler.LessThan
new Expression<Func<bool>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<bool>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.LessThan,
        Type = typeof(bool),
        Left = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_i")
        },
        Right = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_j")
        }
    },
    ReturnType = typeof(bool)
}
---- VBCompiler.LessThanOrEqual
new Expression<Func<bool>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<bool>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.LessThanOrEqual,
        Type = typeof(bool),
        Left = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_i")
        },
        Right = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_j")
        }
    },
    ReturnType = typeof(bool)
}
---- VBCompiler.LogicalNot
new Expression<Func<bool>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<bool>),
    Body = new UnaryExpression {
        NodeType = ExpressionType.Not,
        Type = typeof(bool),
        Operand = new MemberExpression {
            Type = typeof(bool),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_b")
        }
    },
    ReturnType = typeof(bool)
}
---- VBCompiler.Modulo
new Expression<Func<double>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<double>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.Modulo,
        Type = typeof(double),
        Left = new MemberExpression {
            Type = typeof(double),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_x")
        },
        Right = new MemberExpression {
            Type = typeof(double),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_y")
        }
    },
    ReturnType = typeof(double)
}
---- VBCompiler.MultidimensionalArrayOfArray
new Expression<Func<string[,][]>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string[,][]>),
    Body = new NewArrayExpression {
        NodeType = ExpressionType.NewArrayBounds,
        Type = typeof(string[,][]),
        Expressions = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(int),
                Value = 3
            },
            new ConstantExpression {
                Type = typeof(int),
                Value = 2
            }
        }
    },
    ReturnType = typeof(string[,][])
}
---- VBCompiler.MultidimensionWithBounds
new Expression<Func<string[,]>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string[,]>),
    Body = new NewArrayExpression {
        NodeType = ExpressionType.NewArrayBounds,
        Type = typeof(string[,]),
        Expressions = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(int),
                Value = 2
            },
            new ConstantExpression {
                Type = typeof(int),
                Value = 3
            }
        }
    },
    ReturnType = typeof(string[,])
}
---- VBCompiler.Multiply
new Expression<Func<double>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<double>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.Multiply,
        Type = typeof(double),
        Left = new MemberExpression {
            Type = typeof(double),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_x")
        },
        Right = new MemberExpression {
            Type = typeof(double),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_y")
        }
    },
    ReturnType = typeof(double)
}
---- VBCompiler.NamedType
new Expression<Func<Random>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<Random>),
    Body = new NewExpression {
        Type = typeof(Random),
        Constructor = typeof(Random).GetConstructor(new Type[] { })
    },
    ReturnType = typeof(Random)
}
---- VBCompiler.NamedTypeConstructorParameters
new Expression<Func<Foo>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<Foo>),
    Body = new NewExpression {
        Type = typeof(Foo),
        Arguments = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(string),
                Value = "ijkl"
            }
        },
        Constructor = typeof(Foo).GetConstructor(BindingFlags.Instance | BindingFlags.NonPublic, null, new[] { typeof(string) }, null)
    },
    ReturnType = typeof(Foo)
}
---- VBCompiler.NamedTypeConstructorParametersWithInitializers
new Expression<Func<Foo>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<Foo>),
    Body = new MemberInitExpression {
        Type = typeof(Foo),
        NewExpression = new NewExpression {
            Type = typeof(Foo),
            Arguments = new ReadOnlyCollection<Expression> {
                new ConstantExpression {
                    Type = typeof(string),
                    Value = "ijkl"
                }
            },
            Constructor = typeof(Foo).GetConstructor(BindingFlags.Instance | BindingFlags.NonPublic, null, new[] { typeof(string) }, null)
        },
        Bindings = new ReadOnlyCollection<MemberBinding> {
            new MemberAssignment {
                BindingType = MemberBindingType.Assignment,
                Expression = new ConstantExpression {
                    Type = typeof(string),
                    Value = "abcd"
                },
                Member = typeof(Foo).GetProperty("Bar", BindingFlags.Instance | BindingFlags.NonPublic)
            },
            new MemberAssignment {
                BindingType = MemberBindingType.Assignment,
                Expression = new ConstantExpression {
                    Type = typeof(string),
                    Value = "efgh"
                },
                Member = typeof(Foo).GetProperty("Baz", BindingFlags.Instance | BindingFlags.NonPublic)
            }
        }
    },
    ReturnType = typeof(Foo)
}
---- VBCompiler.NamedTypeWithInitializer
new Expression<Func<Foo>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<Foo>),
    Body = new MemberInitExpression {
        Type = typeof(Foo),
        NewExpression = new NewExpression {
            Type = typeof(Foo),
            Constructor = typeof(Foo).GetConstructor(BindingFlags.Instance | BindingFlags.NonPublic, null, new Type[] { }, null)
        },
        Bindings = new ReadOnlyCollection<MemberBinding> {
            new MemberAssignment {
                BindingType = MemberBindingType.Assignment,
                Expression = new ConstantExpression {
                    Type = typeof(string),
                    Value = "abcd"
                },
                Member = typeof(Foo).GetProperty("Bar", BindingFlags.Instance | BindingFlags.NonPublic)
            }
        }
    },
    ReturnType = typeof(Foo)
}
---- VBCompiler.NamedTypeWithInitializers
new Expression<Func<Foo>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<Foo>),
    Body = new MemberInitExpression {
        Type = typeof(Foo),
        NewExpression = new NewExpression {
            Type = typeof(Foo),
            Constructor = typeof(Foo).GetConstructor(BindingFlags.Instance | BindingFlags.NonPublic, null, new Type[] { }, null)
        },
        Bindings = new ReadOnlyCollection<MemberBinding> {
            new MemberAssignment {
                BindingType = MemberBindingType.Assignment,
                Expression = new ConstantExpression {
                    Type = typeof(string),
                    Value = "abcd"
                },
                Member = typeof(Foo).GetProperty("Bar", BindingFlags.Instance | BindingFlags.NonPublic)
            },
            new MemberAssignment {
                BindingType = MemberBindingType.Assignment,
                Expression = new ConstantExpression {
                    Type = typeof(string),
                    Value = "efgh"
                },
                Member = typeof(Foo).GetProperty("Baz", BindingFlags.Instance | BindingFlags.NonPublic)
            }
        }
    },
    ReturnType = typeof(Foo)
}
---- VBCompiler.Negate
new Expression<Func<int>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<int>),
    Body = new UnaryExpression {
        NodeType = ExpressionType.NegateChecked,
        Type = typeof(int),
        Operand = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_i")
        }
    },
    ReturnType = typeof(int)
}
---- VBCompiler.NonInteger
new Expression<Func<double>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<double>),
    Body = new ConstantExpression {
        Type = typeof(double),
        Value = 7.32
    },
    ReturnType = typeof(double)
}
---- VBCompiler.NoParametersNonVoidReturn
new Expression<Func<string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string>),
    Body = new ConstantExpression {
        Type = typeof(string),
        Value = "abcd"
    },
    ReturnType = typeof(string)
}
---- VBCompiler.NoParametersVoidReturn
new Expression<Action> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Action),
    Body = new MethodCallExpression {
        Type = typeof(void),
        Method = typeof(Console).GetMethod("WriteLine", new Type[] { })
    },
    ReturnType = typeof(void)
}
---- VBCompiler.NotEqual
new Expression<Func<bool>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<bool>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.NotEqual,
        Type = typeof(bool),
        Left = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_i")
        },
        Right = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_j")
        }
    },
    ReturnType = typeof(bool)
}
---- VBCompiler.Nothing
new Expression<Func<object>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<object>),
    Body = new ConstantExpression {
        Type = typeof(object)
    },
    ReturnType = typeof(object)
}
---- VBCompiler.NothingString
new Expression<Func<string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string>),
    Body = new ConstantExpression {
        Type = typeof(string)
    },
    ReturnType = typeof(string)
}
---- VBCompiler.OneParameterNonVoidReturn
var s = new ParameterExpression {
    Type = typeof(string),
    IsByRef = false,
    Name = "s"
};

new Expression<Func<string, string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string, string>),
    Parameters = new ReadOnlyCollection<ParameterExpression> {
        s
    },
    Body = s,
    ReturnType = typeof(string)
}
---- VBCompiler.OneParameterVoidReturn
var s = new ParameterExpression {
    Type = typeof(string),
    IsByRef = false,
    Name = "s"
};

new Expression<Action<string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Action<string>),
    Parameters = new ReadOnlyCollection<ParameterExpression> {
        s
    },
    Body = new MethodCallExpression {
        Type = typeof(void),
        Arguments = new ReadOnlyCollection<Expression> {
            s
        },
        Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(string) })
    },
    ReturnType = typeof(void)
}
---- VBCompiler.OrBitwise
new Expression<Func<int>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<int>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.Or,
        Type = typeof(int),
        Left = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_i")
        },
        Right = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_j")
        }
    },
    ReturnType = typeof(int)
}
---- VBCompiler.OrElse
new Expression<Func<bool>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<bool>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.OrElse,
        Type = typeof(bool),
        Left = new MemberExpression {
            Type = typeof(bool),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_b1")
        },
        Right = new MemberExpression {
            Type = typeof(bool),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_b2")
        }
    },
    ReturnType = typeof(bool)
}
---- VBCompiler.OrLogical
new Expression<Func<bool>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<bool>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.Or,
        Type = typeof(bool),
        Left = new MemberExpression {
            Type = typeof(bool),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_b1")
        },
        Right = new MemberExpression {
            Type = typeof(bool),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_b2")
        }
    },
    ReturnType = typeof(bool)
}
---- VBCompiler.Power
new Expression<Func<double>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<double>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.Power,
        Type = typeof(double),
        Left = new MemberExpression {
            Type = typeof(double),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_x")
        },
        Right = new MemberExpression {
            Type = typeof(double),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_y")
        },
        Method = typeof(Math).GetMethod("Pow")
    },
    ReturnType = typeof(double)
}
---- VBCompiler.RightShift
new Expression<Func<int>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<int>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.RightShift,
        Type = typeof(int),
        Left = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_i")
        },
        Right = new BinaryExpression {
            NodeType = ExpressionType.And,
            Type = typeof(int),
            Left = new MemberExpression {
                Type = typeof(int),
                Expression = new ConstantExpression {
                    Type = typeof(<closure>),
                    Value = #<closure>
                },
                Member = typeof(<closure>).GetField("$VB$Local_j")
            },
            Right = new ConstantExpression {
                Type = typeof(int),
                Value = 31
            }
        }
    },
    ReturnType = typeof(int)
}
---- VBCompiler.SingleDimensionInit
new Expression<Func<string[]>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string[]>),
    Body = new NewArrayExpression {
        NodeType = ExpressionType.NewArrayInit,
        Type = typeof(string[]),
        Expressions = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(string)
            }
        }
    },
    ReturnType = typeof(string[])
}
---- VBCompiler.SingleDimensionInitExplicitType
new Expression<Func<object[]>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<object[]>),
    Body = new NewArrayExpression {
        NodeType = ExpressionType.NewArrayInit,
        Type = typeof(object[]),
        Expressions = new ReadOnlyCollection<Expression> {
            new UnaryExpression {
                NodeType = ExpressionType.Convert,
                Type = typeof(object),
                Operand = new ConstantExpression {
                    Type = typeof(string)
                }
            }
        }
    },
    ReturnType = typeof(object[])
}
---- VBCompiler.SingleDimensionWithBounds
new Expression<Func<string[]>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string[]>),
    Body = new NewArrayExpression {
        NodeType = ExpressionType.NewArrayBounds,
        Type = typeof(string[]),
        Expressions = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(int),
                Value = 5
            }
        }
    },
    ReturnType = typeof(string[])
}
---- VBCompiler.StaticMember
new Expression<Func<string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string>),
    Body = new MemberExpression {
        Type = typeof(string),
        Member = typeof(string).GetField("Empty")
    },
    ReturnType = typeof(string)
}
---- VBCompiler.StaticMethod0Arguments
new Expression<Action> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Action),
    Body = new MethodCallExpression {
        Type = typeof(void),
        Method = typeof(Dummy).GetMethod("DummyMethod")
    },
    ReturnType = typeof(void)
}
---- VBCompiler.StaticMethod1Argument
new Expression<Func<string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string>),
    Body = new MethodCallExpression {
        Type = typeof(string),
        Arguments = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(string)
            }
        },
        Method = typeof(string).GetMethod("Intern")
    },
    ReturnType = typeof(string)
}
---- VBCompiler.StaticMethod2Arguments
new Expression<Func<string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string>),
    Body = new MethodCallExpression {
        Type = typeof(string),
        Arguments = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(string),
                Value = ","
            },
            new NewArrayExpression {
                NodeType = ExpressionType.NewArrayInit,
                Type = typeof(string[]),
                Expressions = new ReadOnlyCollection<Expression> {
                    new NewExpression {
                        Type = typeof(string),
                        Arguments = new ReadOnlyCollection<Expression> {
                            new MemberExpression {
                                Type = typeof(char[]),
                                Expression = new ConstantExpression {
                                    Type = typeof(<closure>),
                                    Value = #<closure>
                                },
                                Member = typeof(<closure>).GetField("$VB$Local_arr")
                            }
                        },
                        Constructor = typeof(string).GetConstructor(new[] { typeof(char[]) })
                    }
                }
            }
        },
        Method = typeof(string).GetMethod("Join", 0, new[] { typeof(string), typeof(string[]) })
    },
    ReturnType = typeof(string)
}
---- VBCompiler.StaticMethod2ArgumentsWithoutConversion
new Expression<Func<string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string>),
    Body = new MethodCallExpression {
        Type = typeof(string),
        Arguments = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(string),
                Value = ","
            },
            new MemberExpression {
                Type = typeof(IEnumerable<char>),
                Expression = new ConstantExpression {
                    Type = typeof(<closure>),
                    Value = #<closure>
                },
                Member = typeof(<closure>).GetField("$VB$Local_arr")
            }
        },
        Method = typeof(string).GetMethod("Join", 1, new[] { typeof(string), typeof(IEnumerable<char>) })
    },
    ReturnType = typeof(string)
}
---- VBCompiler.String
new Expression<Func<string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string>),
    Body = new ConstantExpression {
        Type = typeof(string),
        Value = "abcd"
    },
    ReturnType = typeof(string)
}
---- VBCompiler.StringConcat
var s1 = new ParameterExpression {
    Type = typeof(string),
    IsByRef = false,
    Name = "s1"
};
var s2 = new ParameterExpression {
    Type = typeof(string),
    IsByRef = false,
    Name = "s2"
};

new Expression<Func<string, string, string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string, string, string>),
    Parameters = new ReadOnlyCollection<ParameterExpression> {
        s1,
        s2
    },
    Body = new MethodCallExpression {
        Type = typeof(string),
        Arguments = new ReadOnlyCollection<Expression> {
            s1,
            s2
        },
        Method = typeof(string).GetMethod("Concat", 0, new[] { typeof(string), typeof(string) })
    },
    ReturnType = typeof(string)
}
---- VBCompiler.StringConcatOperator
var s1 = new ParameterExpression {
    Type = typeof(string),
    IsByRef = false,
    Name = "s1"
};
var s2 = new ParameterExpression {
    Type = typeof(string),
    IsByRef = false,
    Name = "s2"
};

new Expression<Func<string, string, string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string, string, string>),
    Parameters = new ReadOnlyCollection<ParameterExpression> {
        s1,
        s2
    },
    Body = new MethodCallExpression {
        Type = typeof(string),
        Arguments = new ReadOnlyCollection<Expression> {
            s1,
            s2
        },
        Method = typeof(string).GetMethod("Concat", 0, new[] { typeof(string), typeof(string) })
    },
    ReturnType = typeof(string)
}
---- VBCompiler.StringConcatOperatorParamArray
var s1 = new ParameterExpression {
    Type = typeof(string),
    IsByRef = false,
    Name = "s1"
};
var s2 = new ParameterExpression {
    Type = typeof(string),
    IsByRef = false,
    Name = "s2"
};

new Expression<Func<string, string, string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string, string, string>),
    Parameters = new ReadOnlyCollection<ParameterExpression> {
        s1,
        s2
    },
    Body = new MethodCallExpression {
        Type = typeof(string),
        Arguments = new ReadOnlyCollection<Expression> {
            new NewArrayExpression {
                NodeType = ExpressionType.NewArrayInit,
                Type = typeof(string[]),
                Expressions = new ReadOnlyCollection<Expression> {
                    s1,
                    s2,
                    s1,
                    s2,
                    s1,
                    s2
                }
            }
        },
        Method = typeof(string).GetMethod("Concat", 0, new[] { typeof(string[]) })
    },
    ReturnType = typeof(string)
}
---- VBCompiler.Subtract
new Expression<Func<double>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<double>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.Subtract,
        Type = typeof(double),
        Left = new MemberExpression {
            Type = typeof(double),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_x")
        },
        Right = new MemberExpression {
            Type = typeof(double),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_y")
        }
    },
    ReturnType = typeof(double)
}
---- VBCompiler.True
new Expression<Func<bool>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<bool>),
    Body = new ConstantExpression {
        Type = typeof(bool),
        Value = true
    },
    ReturnType = typeof(bool)
}
---- VBCompiler.TwoParametersNonVoidReturn
var s1 = new ParameterExpression {
    Type = typeof(string),
    IsByRef = false,
    Name = "s1"
};
var s2 = new ParameterExpression {
    Type = typeof(string),
    IsByRef = false,
    Name = "s2"
};

new Expression<Func<string, string, string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string, string, string>),
    Parameters = new ReadOnlyCollection<ParameterExpression> {
        s1,
        s2
    },
    Body = new MethodCallExpression {
        Type = typeof(string),
        Arguments = new ReadOnlyCollection<Expression> {
            s1,
            s2
        },
        Method = typeof(string).GetMethod("Concat", 0, new[] { typeof(string), typeof(string) })
    },
    ReturnType = typeof(string)
}
---- VBCompiler.TwoParametersVoidReturn
var s1 = new ParameterExpression {
    Type = typeof(string),
    IsByRef = false,
    Name = "s1"
};
var s2 = new ParameterExpression {
    Type = typeof(string),
    IsByRef = false,
    Name = "s2"
};

new Expression<Action<string, string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Action<string, string>),
    Parameters = new ReadOnlyCollection<ParameterExpression> {
        s1,
        s2
    },
    Body = new MethodCallExpression {
        Type = typeof(void),
        Arguments = new ReadOnlyCollection<Expression> {
            new MethodCallExpression {
                Type = typeof(string),
                Arguments = new ReadOnlyCollection<Expression> {
                    s1,
                    s2
                },
                Method = typeof(string).GetMethod("Concat", 0, new[] { typeof(string), typeof(string) })
            }
        },
        Method = typeof(Console).GetMethod("WriteLine", new[] { typeof(string) })
    },
    ReturnType = typeof(void)
}
---- VBCompiler.TypeAs
new Expression<Func<string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string>),
    Body = new UnaryExpression {
        NodeType = ExpressionType.TypeAs,
        Type = typeof(string),
        Operand = new MemberExpression {
            Type = typeof(object),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_o")
        }
    },
    ReturnType = typeof(string)
}
---- VBCompiler.TypeCheck
new Expression<Func<bool>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<bool>),
    Body = new TypeBinaryExpression {
        NodeType = ExpressionType.TypeIs,
        Type = typeof(bool),
        Expression = new ConstantExpression {
            Type = typeof(string)
        },
        TypeOperand = typeof(string)
    },
    ReturnType = typeof(bool)
}
---- VBCompiler.TypeIndexer
new Expression<Func<string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string>),
    Body = new MethodCallExpression {
        Type = typeof(string),
        Object = new MemberExpression {
            Type = typeof(List<string>),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_lst")
        },
        Arguments = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(int),
                Value = 3
            }
        },
        Method = typeof(List<string>).GetMethod("get_Item")
    },
    ReturnType = typeof(string)
}
---- VBCompiler.VBDeclaredTypeIndexer
new Expression<Func<int>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<int>),
    Body = new MethodCallExpression {
        Type = typeof(int),
        Object = new MemberExpression {
            Type = typeof(DummyWithDefault),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_x")
        },
        Arguments = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(int),
                Value = 5
            }
        },
        Method = typeof(DummyWithDefault).GetMethod("get_Item")
    },
    ReturnType = typeof(int)
}
---- VBCompiler.LeftEnumNonConstant
new Expression<Func<bool>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<bool>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.GreaterThanOrEqual,
        Type = typeof(bool),
        Left = new UnaryExpression {
            NodeType = ExpressionType.ConvertChecked,
            Type = typeof(int),
            Operand = new MemberExpression {
                Type = typeof(DayOfWeek),
                Expression = new ConstantExpression {
                    Type = typeof(<closure>),
                    Value = #<closure>
                },
                Member = typeof(<closure>).GetField("$VB$Local_dow")
            }
        },
        Right = new ConstantExpression {
            Type = typeof(int),
            Value = 2
        }
    },
    ReturnType = typeof(bool)
}
---- VBCompiler.RightEnumNonConstant
new Expression<Func<bool>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<bool>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.LessThanOrEqual,
        Type = typeof(bool),
        Left = new ConstantExpression {
            Type = typeof(int),
            Value = 2
        },
        Right = new UnaryExpression {
            NodeType = ExpressionType.ConvertChecked,
            Type = typeof(int),
            Operand = new MemberExpression {
                Type = typeof(DayOfWeek),
                Expression = new ConstantExpression {
                    Type = typeof(<closure>),
                    Value = #<closure>
                },
                Member = typeof(<closure>).GetField("$VB$Local_dow")
            }
        }
    },
    ReturnType = typeof(bool)
}
---- VBCompiler.DualNonConstant
new Expression<Func<bool>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<bool>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.Equal,
        Type = typeof(bool),
        Left = new UnaryExpression {
            NodeType = ExpressionType.ConvertChecked,
            Type = typeof(int),
            Operand = new MemberExpression {
                Type = typeof(DayOfWeek),
                Expression = new ConstantExpression {
                    Type = typeof(<closure>),
                    Value = #<closure>
                },
                Member = typeof(<closure>).GetField("$VB$Local_dow1")
            }
        },
        Right = new UnaryExpression {
            NodeType = ExpressionType.ConvertChecked,
            Type = typeof(int),
            Operand = new MemberExpression {
                Type = typeof(DayOfWeek),
                Expression = new ConstantExpression {
                    Type = typeof(<closure>),
                    Value = #<closure>
                },
                Member = typeof(<closure>).GetField("$VB$Local_dow2")
            }
        }
    },
    ReturnType = typeof(bool)
}
---- CSCompiler.LeftEnumNonConstant
new Expression<Func<bool>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<bool>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.GreaterThanOrEqual,
        Type = typeof(bool),
        Left = new UnaryExpression {
            NodeType = ExpressionType.Convert,
            Type = typeof(int),
            Operand = new MemberExpression {
                Type = typeof(DayOfWeek),
                Expression = new ConstantExpression {
                    Type = typeof(<closure>),
                    Value = #<closure>
                },
                Member = typeof(<closure>).GetField("dow")
            }
        },
        Right = new ConstantExpression {
            Type = typeof(int),
            Value = 2
        }
    },
    ReturnType = typeof(bool)
}
---- CSCompiler.RightEnumNonConstant
new Expression<Func<bool>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<bool>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.LessThanOrEqual,
        Type = typeof(bool),
        Left = new ConstantExpression {
            Type = typeof(int),
            Value = 2
        },
        Right = new UnaryExpression {
            NodeType = ExpressionType.Convert,
            Type = typeof(int),
            Operand = new MemberExpression {
                Type = typeof(DayOfWeek),
                Expression = new ConstantExpression {
                    Type = typeof(<closure>),
                    Value = #<closure>
                },
                Member = typeof(<closure>).GetField("dow")
            }
        }
    },
    ReturnType = typeof(bool)
}
---- CSCompiler.DualNonConstant
new Expression<Func<bool>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<bool>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.Equal,
        Type = typeof(bool),
        Left = new UnaryExpression {
            NodeType = ExpressionType.Convert,
            Type = typeof(int),
            Operand = new MemberExpression {
                Type = typeof(DayOfWeek),
                Expression = new ConstantExpression {
                    Type = typeof(<closure>),
                    Value = #<closure>
                },
                Member = typeof(<closure>).GetField("dow1")
            }
        },
        Right = new UnaryExpression {
            NodeType = ExpressionType.Convert,
            Type = typeof(int),
            Operand = new MemberExpression {
                Type = typeof(DayOfWeek),
                Expression = new ConstantExpression {
                    Type = typeof(<closure>),
                    Value = #<closure>
                },
                Member = typeof(<closure>).GetField("dow2")
            }
        }
    },
    ReturnType = typeof(bool)
}
---- VBCompiler.LikeOperatorStrings
var s1 = new ParameterExpression {
    Type = typeof(string),
    IsByRef = false,
    Name = "s1"
};
var s2 = new ParameterExpression {
    Type = typeof(string),
    IsByRef = false,
    Name = "s2"
};

new Expression<Func<string, string, bool>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string, string, bool>),
    Parameters = new ReadOnlyCollection<ParameterExpression> {
        s1,
        s2
    },
    Body = new MethodCallExpression {
        Type = typeof(bool),
        Arguments = new ReadOnlyCollection<Expression> {
            s1,
            s2,
            new ConstantExpression {
                Type = typeof(CompareMethod),
                Value = CompareMethod.Binary
            }
        },
        Method = typeof(LikeOperator).GetMethod("LikeString")
    },
    ReturnType = typeof(bool)
}
---- VBCompiler.LikeOperatorObjects
var o1 = new ParameterExpression {
    Type = typeof(object),
    IsByRef = false,
    Name = "o1"
};
var o2 = new ParameterExpression {
    Type = typeof(object),
    IsByRef = false,
    Name = "o2"
};

new Expression<Func<object, object, object>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<object, object, object>),
    Parameters = new ReadOnlyCollection<ParameterExpression> {
        o1,
        o2
    },
    Body = new MethodCallExpression {
        Type = typeof(object),
        Arguments = new ReadOnlyCollection<Expression> {
            o1,
            o2,
            new ConstantExpression {
                Type = typeof(CompareMethod),
                Value = CompareMethod.Binary
            }
        },
        Method = typeof(LikeOperator).GetMethod("LikeObject")
    },
    ReturnType = typeof(object)
}
---- VBCompiler.ExtensionMethod1Argument
new Expression<Func<List<string>>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<List<string>>),
    Body = new MethodCallExpression {
        Type = typeof(List<string>),
        Arguments = new ReadOnlyCollection<Expression> {
            new MemberExpression {
                Type = typeof(List<string>),
                Expression = new ConstantExpression {
                    Type = typeof(<closure>),
                    Value = #<closure>
                },
                Member = typeof(<closure>).GetField("$VB$Local_lst")
            },
            new ConstantExpression {
                Type = typeof(int),
                Value = 1
            }
        },
        Method = typeof(Dummy).GetMethod("ExtensionMethod1Argument")
    },
    ReturnType = typeof(List<string>)
}
---- VBCompiler.ExtensionMethod1ArgumentWithoutConversion
new Expression<Func<IEnumerable<string>>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<IEnumerable<string>>),
    Body = new MethodCallExpression {
        Type = typeof(IEnumerable<string>),
        Arguments = new ReadOnlyCollection<Expression> {
            new MemberExpression {
                Type = typeof(IEnumerable<string>),
                Expression = new ConstantExpression {
                    Type = typeof(<closure>),
                    Value = #<closure>
                },
                Member = typeof(<closure>).GetField("$VB$Local_lst")
            },
            new ConstantExpression {
                Type = typeof(int),
                Value = 1
            }
        },
        Method = typeof(Dummy).GetMethod("ExtensionMethod1ArgumentEnumerable")
    },
    ReturnType = typeof(IEnumerable<string>)
}
---- VBCompiler.ExtensionMethod2Arguments
new Expression<Func<List<string>>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<List<string>>),
    Body = new MethodCallExpression {
        Type = typeof(List<string>),
        Arguments = new ReadOnlyCollection<Expression> {
            new MemberExpression {
                Type = typeof(List<string>),
                Expression = new ConstantExpression {
                    Type = typeof(<closure>),
                    Value = #<closure>
                },
                Member = typeof(<closure>).GetField("$VB$Local_lst")
            },
            new ConstantExpression {
                Type = typeof(int),
                Value = 5
            },
            new ConstantExpression {
                Type = typeof(int),
                Value = 17
            }
        },
        Method = typeof(Dummy).GetMethod("ExtensionMethod2Arguments")
    },
    ReturnType = typeof(List<string>)
}
---- VBCompiler.ExtensionMethod2ArgumentsWithoutConversion
new Expression<Func<IEnumerable<string>>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<IEnumerable<string>>),
    Body = new MethodCallExpression {
        Type = typeof(IEnumerable<string>),
        Arguments = new ReadOnlyCollection<Expression> {
            new MemberExpression {
                Type = typeof(IEnumerable<string>),
                Expression = new ConstantExpression {
                    Type = typeof(<closure>),
                    Value = #<closure>
                },
                Member = typeof(<closure>).GetField("$VB$Local_lst")
            },
            new ConstantExpression {
                Type = typeof(int),
                Value = 5
            },
            new ConstantExpression {
                Type = typeof(int),
                Value = 6
            }
        },
        Method = typeof(Dummy).GetMethod("ExtensionMethod2ArgumentsEnumerable")
    },
    ReturnType = typeof(IEnumerable<string>)
}
---- CSCompiler.ExtensionMethod1Argument
new Expression<Func<List<string>>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<List<string>>),
    Body = new MethodCallExpression {
        Type = typeof(List<string>),
        Arguments = new ReadOnlyCollection<Expression> {
            new MemberExpression {
                Type = typeof(List<string>),
                Expression = new ConstantExpression {
                    Type = typeof(<closure>),
                    Value = #<closure>
                },
                Member = typeof(<closure>).GetField("lst")
            },
            new ConstantExpression {
                Type = typeof(int),
                Value = 1
            }
        },
        Method = typeof(Dummy).GetMethod("ExtensionMethod1Argument")
    },
    ReturnType = typeof(List<string>)
}
---- CSCompiler.ExtensionMethod2Arguments
new Expression<Func<List<string>>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<List<string>>),
    Body = new MethodCallExpression {
        Type = typeof(List<string>),
        Arguments = new ReadOnlyCollection<Expression> {
            new MemberExpression {
                Type = typeof(List<string>),
                Expression = new ConstantExpression {
                    Type = typeof(<closure>),
                    Value = #<closure>
                },
                Member = typeof(<closure>).GetField("lst")
            },
            new ConstantExpression {
                Type = typeof(int),
                Value = 5
            },
            new ConstantExpression {
                Type = typeof(int),
                Value = 17
            }
        },
        Method = typeof(Dummy).GetMethod("ExtensionMethod2Arguments")
    },
    ReturnType = typeof(List<string>)
}
---- FactoryMethods.ExtensionMethod1Argument
new MethodCallExpression {
    Type = typeof(List<string>),
    Arguments = new ReadOnlyCollection<Expression> {
        lstString,
        new ConstantExpression {
            Type = typeof(int),
            Value = 1
        }
    },
    Method = typeof(Dummy).GetMethod("ExtensionMethod1Argument")
}
---- FactoryMethods.ExtensionMethod2Arguments
new MethodCallExpression {
    Type = typeof(List<string>),
    Arguments = new ReadOnlyCollection<Expression> {
        lstString,
        new ConstantExpression {
            Type = typeof(int),
            Value = 5
        },
        new ConstantExpression {
            Type = typeof(int),
            Value = 17
        }
    },
    Method = typeof(Dummy).GetMethod("ExtensionMethod2Arguments")
}
---- VBCompiler.ExtensionMethod0Arguments
new Expression<Func<int>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<int>),
    Body = new MemberExpression {
        Type = typeof(int),
        Expression = new MemberExpression {
            Type = typeof(List<string>),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("$VB$Local_lst")
        },
        Member = typeof(List<string>).GetProperty("Count")
    },
    ReturnType = typeof(int)
}
---- VBCompiler.ExtensionMethod0ArgumentsWithoutConversion
new Expression<Func<int>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<int>),
    Body = new MethodCallExpression {
        Type = typeof(int),
        Arguments = new ReadOnlyCollection<Expression> {
            new MemberExpression {
                Type = typeof(IEnumerable<string>),
                Expression = new ConstantExpression {
                    Type = typeof(<closure>),
                    Value = #<closure>
                },
                Member = typeof(<closure>).GetField("$VB$Local_lst")
            }
        },
        Method = typeof(Enumerable).GetMethod("Count", new[] { typeof(IEnumerable<string>) })
    },
    ReturnType = typeof(int)
}
---- FactoryMethods.MakeExtensionExpression
new ExtensionExpression {
    NodeType = ExpressionType.Extension,
    Type = typeof(int)
}
---- FactoryMethods.ConstructUnbox
new UnaryExpression {
    NodeType = ExpressionType.Unbox,
    Type = typeof(int),
    Operand = obj
}
---- CSCompiler.RequiredGenericParameters
new Expression<Action> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Action),
    Body = new MethodCallExpression {
        Type = typeof(void),
        Method = typeof(Dummy).GetMethod("DummyMethodWithGenerics")
    },
    ReturnType = typeof(void)
}
---- FactoryMethods.NonVoidSwitch
new SwitchExpression {
    Type = typeof(string),
    SwitchValue = i,
    Cases = new ReadOnlyCollection<SwitchCase> {
        new SwitchCase {
            TestValues = new ReadOnlyCollection<Expression> {
                new ConstantExpression {
                    Type = typeof(int),
                    Value = 1
                }
            },
            Body = new ConstantExpression {
                Type = typeof(string),
                Value = "One"
            }
        },
        new SwitchCase {
            TestValues = new ReadOnlyCollection<Expression> {
                new ConstantExpression {
                    Type = typeof(int),
                    Value = 2
                }
            },
            Body = new ConstantExpression {
                Type = typeof(string),
                Value = "Two"
            }
        },
        new SwitchCase {
            TestValues = new ReadOnlyCollection<Expression> {
                new ConstantExpression {
                    Type = typeof(int),
                    Value = 3
                }
            },
            Body = new ConstantExpression {
                Type = typeof(string),
                Value = "Three"
            }
        }
    },
    DefaultBody = new ConstantExpression {
        Type = typeof(string),
        Value = "Default"
    }
}
---- FactoryMethods.NonVoidSwitchMultilineBodies
new SwitchExpression {
    Type = typeof(string),
    SwitchValue = i,
    Cases = new ReadOnlyCollection<SwitchCase> {
        new SwitchCase {
            TestValues = new ReadOnlyCollection<Expression> {
                new ConstantExpression {
                    Type = typeof(int),
                    Value = 1
                }
            },
            Body = new BlockExpression {
                Type = typeof(string),
                Expressions = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(string)
                    },
                    new ConstantExpression {
                        Type = typeof(string),
                        Value = "One"
                    }
                },
                Result = new ConstantExpression {
                    Type = typeof(string),
                    Value = "One"
                }
            }
        },
        new SwitchCase {
            TestValues = new ReadOnlyCollection<Expression> {
                new ConstantExpression {
                    Type = typeof(int),
                    Value = 2
                }
            },
            Body = new BlockExpression {
                Type = typeof(string),
                Expressions = new ReadOnlyCollection<Expression> {
                    new ConstantExpression {
                        Type = typeof(string)
                    },
                    new ConstantExpression {
                        Type = typeof(string),
                        Value = "Two"
                    }
                },
                Result = new ConstantExpression {
                    Type = typeof(string),
                    Value = "Two"
                }
            }
        }
    },
    DefaultBody = new BlockExpression {
        Type = typeof(string),
        Expressions = new ReadOnlyCollection<Expression> {
            new ConstantExpression {
                Type = typeof(string)
            },
            new ConstantExpression {
                Type = typeof(string),
                Value = "Default"
            }
        },
        Result = new ConstantExpression {
            Type = typeof(string),
            Value = "Default"
        }
    }
}
---- FactoryMethods.NonVoidSwitchMultipleTestValues
new SwitchExpression {
    Type = typeof(string),
    SwitchValue = i,
    Cases = new ReadOnlyCollection<SwitchCase> {
        new SwitchCase {
            TestValues = new ReadOnlyCollection<Expression> {
                new ConstantExpression {
                    Type = typeof(int),
                    Value = 1
                },
                new ConstantExpression {
                    Type = typeof(int),
                    Value = 2
                }
            },
            Body = new ConstantExpression {
                Type = typeof(string),
                Value = "OneTwo"
            }
        },
        new SwitchCase {
            TestValues = new ReadOnlyCollection<Expression> {
                new ConstantExpression {
                    Type = typeof(int),
                    Value = 3
                },
                new ConstantExpression {
                    Type = typeof(int),
                    Value = 4
                }
            },
            Body = new ConstantExpression {
                Type = typeof(string),
                Value = "ThreeFour"
            }
        }
    },
    DefaultBody = new ConstantExpression {
        Type = typeof(string),
        Value = "Default"
    }
}
---- FactoryMethods.DynamicBinaryOperation
new DynamicExpression {
    Type = typeof(double),
    Binder = #CSharpBinaryOperationBinder,
    Arguments = new ReadOnlyCollection<Expression> {
        x,
        y
    },
    DelegateType = typeof(Func<CallSite, double, double, double>)
}
---- FactoryMethods.DynamicConvertOperation
new DynamicExpression {
    Type = typeof(int),
    Binder = #CSharpConvertBinder,
    Arguments = new ReadOnlyCollection<Expression> {
        x
    },
    DelegateType = typeof(Func<CallSite, double, int>)
}
---- FactoryMethods.DynamicUnaryOperation
new DynamicExpression {
    Type = typeof(bool),
    Binder = #CSharpUnaryOperationBinder,
    Arguments = new ReadOnlyCollection<Expression> {
        b1
    },
    DelegateType = typeof(Func<CallSite, bool, bool>)
}
---- FactoryMethods.UnnamedParameter
var $var0 = new ParameterExpression {
    Type = typeof(string),
    IsByRef = false
};

new Expression<Func<string, bool>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string, bool>),
    Parameters = new ReadOnlyCollection<ParameterExpression> {
        $var0
    },
    Body = new BinaryExpression {
        NodeType = ExpressionType.Equal,
        Type = typeof(bool),
        Left = $var0,
        Right = $var0,
        Method = typeof(string).GetMethod("op_Equality")
    },
    ReturnType = typeof(bool)
}
---- FactoryMethods.WhitespaceNamedParameter
var $x_y = new ParameterExpression {
    Type = typeof(string),
    IsByRef = false,
    Name = "x y"
};

new Expression<Func<string, string>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string, string>),
    Parameters = new ReadOnlyCollection<ParameterExpression> {
        $x_y
    },
    Body = $x_y,
    ReturnType = typeof(string)
}
---- VBCompiler.SingleDimensionWithBoundsExpression
new Expression<Func<string[]>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string[]>),
    Body = new NewArrayExpression {
        NodeType = ExpressionType.NewArrayBounds,
        Type = typeof(string[]),
        Expressions = new ReadOnlyCollection<Expression> {
            new BinaryExpression {
                NodeType = ExpressionType.AddChecked,
                Type = typeof(int),
                Left = new MemberExpression {
                    Type = typeof(int),
                    Expression = new ConstantExpression {
                        Type = typeof(<closure>),
                        Value = #<closure>
                    },
                    Member = typeof(<closure>).GetField("$VB$Local_bounds")
                },
                Right = new ConstantExpression {
                    Type = typeof(int),
                    Value = 1
                }
            }
        }
    },
    ReturnType = typeof(string[])
}
---- VBCompiler.MultidimensionWithBoundsExpression
new Expression<Func<string[,]>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string[,]>),
    Body = new NewArrayExpression {
        NodeType = ExpressionType.NewArrayBounds,
        Type = typeof(string[,]),
        Expressions = new ReadOnlyCollection<Expression> {
            new BinaryExpression {
                NodeType = ExpressionType.AddChecked,
                Type = typeof(int),
                Left = new MemberExpression {
                    Type = typeof(int),
                    Expression = new ConstantExpression {
                        Type = typeof(<closure>),
                        Value = #<closure>
                    },
                    Member = typeof(<closure>).GetField("$VB$Local_bound1")
                },
                Right = new ConstantExpression {
                    Type = typeof(int),
                    Value = 1
                }
            },
            new BinaryExpression {
                NodeType = ExpressionType.AddChecked,
                Type = typeof(int),
                Left = new MemberExpression {
                    Type = typeof(int),
                    Expression = new ConstantExpression {
                        Type = typeof(<closure>),
                        Value = #<closure>
                    },
                    Member = typeof(<closure>).GetField("$VB$Local_bound2")
                },
                Right = new ConstantExpression {
                    Type = typeof(int),
                    Value = 1
                }
            }
        }
    },
    ReturnType = typeof(string[,])
}
---- VBCompiler.JaggedWithBoundsExpression
new Expression<Func<string[][]>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<string[][]>),
    Body = new NewArrayExpression {
        NodeType = ExpressionType.NewArrayBounds,
        Type = typeof(string[][]),
        Expressions = new ReadOnlyCollection<Expression> {
            new BinaryExpression {
                NodeType = ExpressionType.AddChecked,
                Type = typeof(int),
                Left = new MemberExpression {
                    Type = typeof(int),
                    Expression = new ConstantExpression {
                        Type = typeof(<closure>),
                        Value = #<closure>
                    },
                    Member = typeof(<closure>).GetField("$VB$Local_bound")
                },
                Right = new ConstantExpression {
                    Type = typeof(int),
                    Value = 1
                }
            }
        }
    },
    ReturnType = typeof(string[][])
}
---- VBCompiler.ExtensionMethod1ArgumentWithConversion
new Expression<Func<IEnumerable<string>>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<IEnumerable<string>>),
    Body = new MethodCallExpression {
        Type = typeof(IEnumerable<string>),
        Arguments = new ReadOnlyCollection<Expression> {
            new UnaryExpression {
                NodeType = ExpressionType.Convert,
                Type = typeof(IEnumerable<string>),
                Operand = new MemberExpression {
                    Type = typeof(List<string>),
                    Expression = new ConstantExpression {
                        Type = typeof(<closure>),
                        Value = #<closure>
                    },
                    Member = typeof(<closure>).GetField("$VB$Local_lst")
                }
            },
            new ConstantExpression {
                Type = typeof(int),
                Value = 1
            }
        },
        Method = typeof(Dummy).GetMethod("ExtensionMethod1ArgumentEnumerable")
    },
    ReturnType = typeof(IEnumerable<string>)
}
---- VBCompiler.ExtensionMethod2ArgumentsWithConversion
new Expression<Func<IEnumerable<string>>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<IEnumerable<string>>),
    Body = new MethodCallExpression {
        Type = typeof(IEnumerable<string>),
        Arguments = new ReadOnlyCollection<Expression> {
            new UnaryExpression {
                NodeType = ExpressionType.Convert,
                Type = typeof(IEnumerable<string>),
                Operand = new MemberExpression {
                    Type = typeof(List<string>),
                    Expression = new ConstantExpression {
                        Type = typeof(<closure>),
                        Value = #<closure>
                    },
                    Member = typeof(<closure>).GetField("$VB$Local_lst")
                }
            },
            new ConstantExpression {
                Type = typeof(int),
                Value = 5
            },
            new ConstantExpression {
                Type = typeof(int),
                Value = 6
            }
        },
        Method = typeof(Dummy).GetMethod("ExtensionMethod2ArgumentsEnumerable")
    },
    ReturnType = typeof(IEnumerable<string>)
}
---- VBCompiler.DivideIntegers
new Expression<Func<double>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<double>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.Divide,
        Type = typeof(double),
        Left = new UnaryExpression {
            NodeType = ExpressionType.Convert,
            Type = typeof(double),
            Operand = new MemberExpression {
                Type = typeof(int),
                Expression = new ConstantExpression {
                    Type = typeof(<closure>),
                    Value = #<closure>
                },
                Member = typeof(<closure>).GetField("$VB$Local_x")
            }
        },
        Right = new UnaryExpression {
            NodeType = ExpressionType.Convert,
            Type = typeof(double),
            Operand = new MemberExpression {
                Type = typeof(int),
                Expression = new ConstantExpression {
                    Type = typeof(<closure>),
                    Value = #<closure>
                },
                Member = typeof(<closure>).GetField("$VB$Local_y")
            }
        }
    },
    ReturnType = typeof(double)
}
---- VBCompiler.DivideIntegral
new Expression<Func<long>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<long>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.Divide,
        Type = typeof(long),
        Left = new UnaryExpression {
            NodeType = ExpressionType.ConvertChecked,
            Type = typeof(long),
            Method = typeof(Convert).GetMethod("ToInt64", new[] { typeof(double) }),
            Operand = new MemberExpression {
                Type = typeof(double),
                Expression = new ConstantExpression {
                    Type = typeof(<closure>),
                    Value = #<closure>
                },
                Member = typeof(<closure>).GetField("$VB$Local_x")
            }
        },
        Right = new UnaryExpression {
            NodeType = ExpressionType.ConvertChecked,
            Type = typeof(long),
            Method = typeof(Convert).GetMethod("ToInt64", new[] { typeof(double) }),
            Operand = new MemberExpression {
                Type = typeof(double),
                Expression = new ConstantExpression {
                    Type = typeof(<closure>),
                    Value = #<closure>
                },
                Member = typeof(<closure>).GetField("$VB$Local_y")
            }
        }
    },
    ReturnType = typeof(long)
}
---- CSCompiler.DivideIntegral
new Expression<Func<int>> {
    NodeType = ExpressionType.Lambda,
    Type = typeof(Func<int>),
    Body = new BinaryExpression {
        NodeType = ExpressionType.Divide,
        Type = typeof(int),
        Left = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("x")
        },
        Right = new MemberExpression {
            Type = typeof(int),
            Expression = new ConstantExpression {
                Type = typeof(<closure>),
                Value = #<closure>
            },
            Member = typeof(<closure>).GetField("y")
        }
    },
    ReturnType = typeof(int)
}
---- FactoryMethods.MakeEqualsEnum
new BinaryExpression {
    NodeType = ExpressionType.Equal,
    Type = typeof(bool),
    Left = new UnaryExpression {
        NodeType = ExpressionType.ConvertChecked,
        Type = typeof(int),
        Operand = new ConstantExpression {
            Type = typeof(DayOfWeek),
            Value = DayOfWeek.Tuesday
        }
    },
    Right = new UnaryExpression {
        NodeType = ExpressionType.ConvertChecked,
        Type = typeof(int),
        Operand = new ConstantExpression {
            Type = typeof(DayOfWeek),
            Value = DayOfWeek.Monday
        }
    }
}
------